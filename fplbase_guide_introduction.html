<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>FPLBase: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
<script>
  /**
   * Check if the browser rendering this page is being run on an Android device.
   * It checks if the string 'android' is found in the browser's `userAgent`.
   * @return {boolean} This returns `true` if the browser's `userAgent` contains
   * the string 'android' (indicating that the browser is on an Android device).
   * Otherwise, it returns `false`.
   */
  function isAndroidDevice() {
    if (navigator && navigator.userAgent) {
      return navigator.userAgent.toLowerCase().indexOf('android') != -1;
    } else {
      return false;
    }
  }
  /**
   * Check if an HTML `class` attribute is in the browser-specific format.
   * @param {string} An HTML `class` attribute in the format 'browser-{device}'.
   * @return {boolean} Returns `true` if `browserClass` was in the valid format,
   * prefixed with 'browser-'. Otherwise, it returns false.
   */
  function isBrowserSpecificClassName(browserClass) {
    if (browserClass && browserClass.substring(0, 8) == 'browser-' &&
        browserClass.length > 8) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Get all the HTML Elements with browser-specific `class` attributes.
   * @return {array} Returns an array of all the HTML Elements with a `class`
   * attribute that is prefixed with `browser-`.
   */
  function getAllBrowserSpecificElements() {
    if (document) {
      var htmlElements = document.getElementsByTagName("*");
      var browserSpecificElements = [];
      for (var i = 0; i < htmlElements.length; i++) {
        if (isBrowserSpecificClassName(htmlElements[i].className)) {
          browserSpecificElements.push(htmlElements[i]);
        }
      }
      return browserSpecificElements;
    } else {
      return null;
    }
  }
  /**
   * Given a browser-specific HTML `class` attribute, extract the device name.
   * @param {string} browserClass The string name of an HTML `class` attribute,
   * in the format `browser-{device}`.
   * @return {string} Returns a string containing only the device portion of
   * the class name. If the input was invalid, then it returns `null`.
   */
  function extractDeviceFromBrowserClass(browserClass) {
    if (isBrowserSpecificClassName(browserClass)) {
      return browserClass.substring(8);
    }
    else {
      return null;
    }
  }
  /**
   * Hide device specific elements that do not apply to the current device.
   */
  function handleDeviceSpecificLoading() {
    var browserSpecificElements = getAllBrowserSpecificElements();
    for (var i = 0; i < browserSpecificElements.length; i++) {
      var device = extractDeviceFromBrowserClass(browserSpecificElements[i].className);
      if (device && !isAndroidDevice() && device == 'android') {
        browserSpecificElements[i].innerHTML = '';
      } else if(device && isAndroidDevice() && device == 'desktop') {
        browserSpecificElements[i].innerHTML = '';
      }
    }
  }
  $(document).ready(handleDeviceSpecificLoading);
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FPLBase
   </div>
   <div style="font-size:12px;">
	 An open source project by
     <a href="https://developers.google.com/games/#Tools">FPL</a>.
  </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer's&#160;Guide</span></a></li>
      <li><a href="fplbase_api_reference.html"><span>API&#160;reference</span></a></li>
      <li><a href="contributing.html"><span>Contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('fplbase_guide_introduction.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="fplbase_introduction"></a>
Introduction</h1>
<p>This document outlines the components that make up FPLBase.</p>
<h1><a class="anchor" id="fplbase_sdl"></a>
SDL</h1>
<p>We (optionally) use <a href="https://www.libsdl.org/">SDL</a> (Simple Directmedia Layer) as our lowest level layer. SDL is an Open Source cross platform layer providing OpenGL context creation, input, and other things a game needs to run on a platform, without having to write any platform specific code. It has been in development for a long time, and has very robust support for mobile (Android, iOS), desktop (Windows, OS X, Linux), and even is available for the web through asm.js.</p>
<p>SDL together with OpenGL(ES) and C++ provide an excellent basis for making great cross platform games.</p>
<p>If you prefer to initialize your own OpenGL context, you can link to the <code>fplbase_stdlib</code> library instead of the <code>fplbase</code> library (see CMakeLists.txt). All the functionality of fplbase is still available: loading meshes, shaders, and textures, and hiding the OpenGL details from your code.</p>
<h1><a class="anchor" id="fplbase_components"></a>
Components</h1>
<p>Directly on top of SDL sit two systems, the renderer (<code><a class="el" href="renderer_8h.html">renderer.h</a></code>) and the input system (<code><a class="el" href="input_8h.html">input.h</a></code>). On top of the renderer sits two more (optional) systems, the asset manager (<code><a class="el" href="asset__manager_8h.html">asset_manager.h</a></code>) and the asynchronous loader (<code><a class="el" href="async__loader_8h.html">async_loader.h</a></code>).</p>
<p>To represent resources created by the renderer (or asset manager) we have:</p>
<ul>
<li><code>Shader</code> (<code><a class="el" href="shader_8h.html">shader.h</a></code>)</li>
<li><code>Mesh</code> (<code><a class="el" href="mesh_8h.html">mesh.h</a></code>)</li>
<li><code>Texture</code> / <code>Material</code> (<code><a class="el" href="material_8h.html">material.h</a></code>)</li>
</ul>
<p>The renderer also depends upon our <a href="http://google.github.io/mathfu">MathFu</a> library for all its vector and matrix datatypes. The asset manager depends on our <a href="http://google.github.io/flatbuffers/">FlatBuffers</a> serialization library.</p>
<h1><a class="anchor" id="fplbase_renderer"></a>
Basic initialization and rendering</h1>
<p>The Renderer is the core of the engine, and is responsible for creating the OpenGL context and OpenGL resources such as shaders and textures.</p>
<p>The basic flow of using this lower level layer to create a fully functioning program is as follows:</p>
<ul>
<li>Instantiate the <code>Renderer</code>, and call <code>Initialize</code> on it. This will get your OpenGL context set up, and a window/screen ready to draw on: <div class="fragment"><div class="line">Renderer renderer;</div>
<div class="line">renderer.Initialize(vec2i(960, 640), <span class="stringliteral">&quot;Simple FPLBase example&quot;</span>);</div>
</div><!-- fragment --> The size argument is only really used for the desktop. If initialize fails (returns false), you can get a more informative error string by calling <code>renderer.last_error()</code>.</li>
<li>Create the input system: <div class="fragment"><div class="line">InputSystem input;</div>
<div class="line">input.Initialize();</div>
</div><!-- fragment --> This doesn't fail.</li>
<li>Create resources. <code>CompileAndLinkShader</code> will turn two shader strings (GLSL vertex and pixel shader) into a <code>Shader</code> object: <div class="fragment"><div class="line"><span class="keyword">auto</span> shader = renderer.CompileAndLinkShader(vertex_shader, fragment_shader);</div>
</div><!-- fragment --> (for even more convenient methods that will load directly from file, see the material manager below). Shaders failing to compiler can generate complex errors, so be sure to check the contents of <code>last_error()</code> when <code>shader</code> is null. For more resource types, see below.</li>
<li>Now you're ready to run your main loop. Call <code>AdvanceFrame</code> on the renderer to swap buffers and do general initialisation of the frame, likely followed by <code>ClearFrameBuffer</code>. <div class="fragment"><div class="line"><span class="keywordflow">while</span> (!input.exit_requested()) {</div>
<div class="line">  renderer.AdvanceFrame(input.minimized(), input.Time());</div>
<div class="line">  input.AdvanceFrame(&amp;renderer.window_size());</div>
<div class="line">  renderer.ClearFrameBuffer(background_color);</div>
<div class="line">  <span class="comment">// Render stuff here.</span></div>
<div class="line">}</div>
</div><!-- fragment --> We use the input system to see if an exit has been requested (close button, app shut down). <code>AdvanceFrame</code> for the input system advances the time, and collects new input events.</li>
<li>Before rendering anything, call the renderer's <code>set_model_view_projection()</code>. Use our separate <a href="http://google.github.io/mathfu">MathFu</a> library to combine matrices depending on whether you're creating a 2D or 3D scene, e.g. <code>mathfu::mat4::Ortho</code> and <code>mathfu::mat4::Perspective</code>. <div class="fragment"><div class="line">renderer.set_model_view_projection(</div>
<div class="line">  mathfu::mat4::Ortho(-1.0, 1.0, -1.5, 1.5, -1.0, 1.0));</div>
</div><!-- fragment --> Creates a 2D coordinate space with (0,0) in the center and (3,2) in size.</li>
<li>Now use the shader you've created by calling <code>Set</code> on it. This will make it active, and also upload any renderer variables (such as <code>model_view_projection</code>), ready to be used by the shader. <div class="fragment"><div class="line">shader-&gt;Set(renderer);</div>
</div><!-- fragment --></li>
<li>Finally, you can now render something! Lets use use convenient helper function that gets us a quad (or 2 sprite): <div class="fragment"><div class="line">Mesh::RenderAAQuadAlongX(mathfu::vec3(-0.5f, -0.5f, 0),</div>
<div class="line">                         mathfu::vec3( 0.5f,  0.5f, 0));</div>
</div><!-- fragment --> For more complex meshes, see below.</li>
</ul>
<p>Putting this all together, we get:</p>
<div class="fragment"><div class="line">Renderer renderer;</div>
<div class="line">renderer.Initialize(vec2i(960, 640), <span class="stringliteral">&quot;Simple FPLBase example&quot;</span>);</div>
<div class="line"></div>
<div class="line">InputSystem input;</div>
<div class="line">input.Initialize();</div>
<div class="line"></div>
<div class="line"><span class="comment">// A vertex shader that passes untransformed position thru.</span></div>
<div class="line"><span class="keyword">auto</span> vertex_shader =</div>
<div class="line">  <span class="stringliteral">&quot;attribute vec4 aPosition;\n&quot;</span></div>
<div class="line">  <span class="stringliteral">&quot;void main() { gl_Position = aPosition; }\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// A fragment shader that outputs a green pixel.</span></div>
<div class="line"><span class="keyword">auto</span> fragment_shader =</div>
<div class="line">  <span class="stringliteral">&quot;void main() { gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); }\n&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> shader = renderer.CompileAndLinkShader(vertex_shader, fragment_shader);</div>
<div class="line">assert(shader);</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (!input.exit_requested()) {</div>
<div class="line">  renderer.AdvanceFrame(input.minimized(), input.Time());</div>
<div class="line">  input.AdvanceFrame(&amp;renderer.window_size());</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">float</span> color = (1.0f - cos(input.Time())) / 2.0f;</div>
<div class="line">  renderer.ClearFrameBuffer(mathfu::vec4(color, 0.0f, color, 1.0f));</div>
<div class="line"></div>
<div class="line">  renderer.set_model_view_projection(</div>
<div class="line">    mathfu::mat4::Ortho(-1.0, 1.0, -1.5, 1.5, -1.0, 1.0));</div>
<div class="line"></div>
<div class="line">  shader-&gt;Set(renderer);</div>
<div class="line"></div>
<div class="line">  Mesh::RenderAAQuadAlongX(mathfu::vec3(-0.5f, -0.5f, 0),</div>
<div class="line">                           mathfu::vec3( 0.5f,  0.5f, 0));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">renderer.ShutDown();</div>
</div><!-- fragment --><h1><a class="anchor" id="fplbase_matman"></a>
Asset Manager</h1>
<p>The renderer is deliberately a bare minimum system that takes care of creating and using resources, but not <em>managing</em> them. The asset manager takes care of loading from disk, and caching resources, but is deliberately seperate from the renderer, such that it is easy to replace with something else should the need arise.</p>
<p>Where the renderer reads from memory buffers, the material manager loads files. To keep this cross platform, any resources should be in a folder called <code>assets</code> under the project root. All paths you specify are relative to this folder.</p>
<p>Create one by passing the Renderer that will do the actual creation of resources: </p>
<div class="fragment"><div class="line">fpl::AssetManager asset_manager(renderer);</div>
</div><!-- fragment --><p>Once you've instantiated the <code>AssetManager</code>, calls like <code>LoadShader</code> will conveniently construct a <code>Shader</code> from two files. It does this by suffixing <code>.glslv</code> and <code>.glslf</code> to the filename you pass.</p>
<p>Similarly, <code>LoadTexture</code> will load a TGA or WebP file straight into a <code>Texture</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> shader = asset_manager.LoadShader(<span class="stringliteral">&quot;tex&quot;</span>);</div>
<div class="line">assert(shader);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> tex = asset_manager.LoadTexture(<span class="stringliteral">&quot;tex.webp&quot;</span>);</div>
<div class="line">assert(tex);</div>
</div><!-- fragment --><p>All methods that start with <code>Load</code> have the property that if you ask to load a file that has been loaded before, it just instantly return the previously created resource, and only do any actual loading if not. As before, <code>last_error()</code> will have a descriptive message if this fails.</p>
<p>Alternatively, there are <code>Find</code> versions of these methods that will return <code>nullptr</code> if the resource wasn't previously loaded.</p>
<p>More high-level than loading individual textures is loading a <code>Material</code>, which is a set of textures all meant to be used in the same draw call, bundled with rendering flags such as the desired alpha blending mode etc. You create an actual material file by writing a small .json file which specifies the texture filenames and other properties, e.g.:</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  texture_filenames: [ <span class="stringliteral">&quot;diffuse.webp&quot;</span>, <span class="stringliteral">&quot;normal.webp&quot;</span> ],</div>
<div class="line">  blendmode: OFF</div>
<div class="line">}</div>
</div><!-- fragment --><p> (for more, see <code>schemas/material.fbs</code>). This JSON file can be converted to a binary file by our <a href="http://google.github.io/flatbuffers/">FlatBuffers</a> serialization library, the result of which can be passed to <code>LoadMaterial</code> that will load all referenced textures and create a <code>Material</code> object (which can be attached to <code>Mesh</code>).</p>
<p>Meshes load similary using <code>LoadMesh</code>, to find out how to create these files, see <a class="el" href="fplbase_guide_mesh_pipeline.html">MeshPipeline</a>.</p>
<p>A simple example, which could replace the shader loading in the above example, and also loads a texture:</p>
<div class="fragment"><div class="line">fpl::AssetManager asset_manager(renderer);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> shader = asset_manager.LoadShader(<span class="stringliteral">&quot;tex&quot;</span>);</div>
<div class="line">assert(shader);</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> tex = asset_manager.LoadTexture(<span class="stringliteral">&quot;tex.webp&quot;</span>);</div>
<div class="line">assert(tex);</div>
<div class="line"></div>
<div class="line">asset_manager.StartLoadingTextures();</div>
<div class="line"><span class="keywordflow">while</span> (!asset_manager.TryFinalize()) {</div>
<div class="line">  <span class="comment">// Can display loading screen here.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>What was that while loop needed for? See [Asynchronous Loader][fplbase_async_loader].</p>
<p>Note: for fast loading and efficient GPU usage, use of compressed ETC2 format textures in a .ktx file is recommended. Loading will automatically fall-back to .webp if the hardware does not support it, i.e systems that don't support OpenGL 3.0. Alternatively, use ETC1 which is always supported. Generate these with e.g: </p>
<div class="fragment"><div class="line">etcpack mytexture.png mytexture.ktx -c etc2 -f RGBA -mipmaps -ktx</div>
</div><!-- fragment --><h1><a class="anchor" id="fplbase_async_loader"></a>
Asynchronous Loader</h1>
<p>Loading resources can take a long time, and can be sped up by loading heavy resources (such as textures) in parallel with the rest of the game initialization. Even if speed is not the issue, just being able to conveniently render a loading animation is nice to have.</p>
<p><code>AsyncLoader</code> takes care of all that, hiding the gory details of threading from you. It is fully integrated with the material manager, so using it is relatively simple:</p>
<ul>
<li>Load all your resources as normal. You will receive <code>Texture</code> and <code>Material</code> objects, but these won't actually have any texture data associated with them yet, as textures haven't loaded yet.</li>
<li>Once you've queued up all your resources, call <code>StartLoadingTextures</code> on the material manager to get the loading started.</li>
<li>Now, enter your frame loop as normal. Call <code>TryFinalize</code> which will check if all textures have been loaded. If it returns false, you should display a loading screen, otherwise render the game as normal.</li>
<li>Your loading screen might want to use textures also. Since the loader loads textures in the order they were requested, make sure you queue up your loading screen textures first. If the <code>Texture::id()</code> is non-zero, it can already be used.</li>
</ul>
<h1><a class="anchor" id="fplbase_renderer_resources"></a>
Instantiating resources with the renderer</h1>
<p>We already saw how to load shaders directly from memory without using the asset manager, we can do that with other resources too, if you prefer to do your own asset management:</p>
<p><code>LoadAndUnpackTexture</code> will take a file (currently WebP/TGA/KTX formats) and turn it into a raw buffer which <code>CreateTexture</code> turns into an OpenGL texture.</p>
<p>There's several ways to render or create meshes. We already saw <code>RenderAAQuadAlongX</code> which is the simplest way to get geometry on screen. A more general way is <code>RenderArray</code> which will render a mesh on the fly from any indices and vertices:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">fpl::Attribute</a> format[] = {</div>
<div class="line">  fpl::Attribute::kPosition3f, <a class="code" href="group__fplbase__mesh.html#gga32e078df53a6a42cb90430d93d4df3f5ad6fe577dc2b397bb3a6922341656a5e9">fpl::Attribute::kEND</a></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> indices[] = { 0, 1, 2 };</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> vertices[] = {</div>
<div class="line">  -.5f, -.5f, 0.0f,</div>
<div class="line">  0.0f, 0.5f, 0.0f,</div>
<div class="line">  0.5f, -.5f, 0.0f</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">fpl::Mesh::RenderArray(fpl::Mesh::Primitive::kTriangles, 3, format,</div>
<div class="line">                       <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 3, vertices, indices);</div>
</div><!-- fragment --><p><code>format</code> specifies what kind of attributes our vertex data contains, here only positions. Vertex data must always be interleaved.</p>
<p>Rendering on the fly is convenient, but for the best performance you should always construct Mesh objects, which deal with uploading of vertex and index data just once. Given the data in the above example, that would look like: </p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> mesh = <span class="keyword">new</span> Mesh(vertices, 3, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 3, format);</div>
<div class="line">mesh-&gt;AddIndices(indices, 3, material);</div>
</div><!-- fragment --><p> You may call AddIndices more than once to create multiple different surfaces (with different textures) that make use of the same geometry.</p>
<p>You'll need a material which you can instantiate using the asset manager, or manually.</p>
<p>Inside your rendering loop, now all you have to do is call: </p>
<div class="fragment"><div class="line">mesh-&gt;Render(renderer);</div>
</div><!-- fragment --><p> This will render all surfaces contained, set all textures etc.</p>
<h1><a class="anchor" id="fplbase_input"></a>
Input System</h1>
<p><code>InputSystem</code> deals with time, touch/mouse/keyboard/gamepad input, and lifecycle events.</p>
<p>As we saw above, to initialize it call <code>Initialize</code>, and once per frame call <code>AdvanceFrame</code> right after you called the same method on the renderer. This collects new input events from the system to be reflected in its internal state.</p>
<p>Call <code>Time</code> for seconds since game start, and <code>DeltaTime</code> for seconds since the last frame. <code>Time</code> is updated only once per frame, to ensure that all animations/simulations that happen during a frame stay in sync with rendering. If instead you want time for profiling, call <code>RealTime</code> which recomputes the current time each time it is called.</p>
<p>Now you can query the state of the inputs you're interested in. For example, call <code>GetButton</code> with one of the constants from <code><a class="el" href="input_8h.html">input.h</a></code> which can either be a keyboard key, or a pointer (meaning the mouse or touch inputs, depending on platform) or a gamepad button, and you can see if it went down or up this last frame, or wether it is currently down. The <code>Pointer</code> objects can tell you more about their current position. For example:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (input.GetButton(K_POINTER1).went_down()) {</div>
<div class="line">  <span class="keyword">auto</span> &amp;pos = input.get_pointers()[0].mousepos;</div>
<div class="line">  printf(<span class="stringliteral">&quot;finger/mouse hit at %d, %d\n&quot;</span>, pos.x, pos.y);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-49880327-7', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>
