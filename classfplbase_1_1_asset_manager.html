<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>FPLBase: fplbase::AssetManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
<script>
  /**
   * Check if the browser rendering this page is being run on an Android device.
   * It checks if the string 'android' is found in the browser's `userAgent`.
   * @return {boolean} This returns `true` if the browser's `userAgent` contains
   * the string 'android' (indicating that the browser is on an Android device).
   * Otherwise, it returns `false`.
   */
  function isAndroidDevice() {
    if (navigator && navigator.userAgent) {
      return navigator.userAgent.toLowerCase().indexOf('android') != -1;
    } else {
      return false;
    }
  }
  /**
   * Check if an HTML `class` attribute is in the browser-specific format.
   * @param {string} An HTML `class` attribute in the format 'browser-{device}'.
   * @return {boolean} Returns `true` if `browserClass` was in the valid format,
   * prefixed with 'browser-'. Otherwise, it returns false.
   */
  function isBrowserSpecificClassName(browserClass) {
    if (browserClass && browserClass.substring(0, 8) == 'browser-' &&
        browserClass.length > 8) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Get all the HTML Elements with browser-specific `class` attributes.
   * @return {array} Returns an array of all the HTML Elements with a `class`
   * attribute that is prefixed with `browser-`.
   */
  function getAllBrowserSpecificElements() {
    if (document) {
      var htmlElements = document.getElementsByTagName("*");
      var browserSpecificElements = [];
      for (var i = 0; i < htmlElements.length; i++) {
        if (isBrowserSpecificClassName(htmlElements[i].className)) {
          browserSpecificElements.push(htmlElements[i]);
        }
      }
      return browserSpecificElements;
    } else {
      return null;
    }
  }
  /**
   * Given a browser-specific HTML `class` attribute, extract the device name.
   * @param {string} browserClass The string name of an HTML `class` attribute,
   * in the format `browser-{device}`.
   * @return {string} Returns a string containing only the device portion of
   * the class name. If the input was invalid, then it returns `null`.
   */
  function extractDeviceFromBrowserClass(browserClass) {
    if (isBrowserSpecificClassName(browserClass)) {
      return browserClass.substring(8);
    }
    else {
      return null;
    }
  }
  /**
   * Hide device specific elements that do not apply to the current device.
   */
  function handleDeviceSpecificLoading() {
    var browserSpecificElements = getAllBrowserSpecificElements();
    for (var i = 0; i < browserSpecificElements.length; i++) {
      var device = extractDeviceFromBrowserClass(browserSpecificElements[i].className);
      if (device && !isAndroidDevice() && device == 'android') {
        browserSpecificElements[i].innerHTML = '';
      } else if(device && isAndroidDevice() && device == 'desktop') {
        browserSpecificElements[i].innerHTML = '';
      }
    }
  }
  $(document).ready(handleDeviceSpecificLoading);
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FPLBase
   </div>
   <div style="font-size:12px;">
	 An open source project by
     <a href="https://developers.google.com/games/#Tools">FPL</a>.
  </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="usergroup0.html"><span>Programmer's&#160;Guide</span></a></li>
      <li class="current"><a href="fplbase_api_reference.html"><span>API&#160;reference</span></a></li>
      <li><a href="contributing.html"><span>Contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfplbase_1_1_asset_manager.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classfplbase_1_1_asset_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fplbase::AssetManager Class Reference<div class="ingroups"><a class="el" href="group__fplbase__asset__manager.html">Fplbase_asset_manager</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Central place to own game assets loaded from disk.  
 <a href="classfplbase_1_1_asset_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="asset__manager_8h_source.html">asset_manager.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Central place to own game assets loaded from disk. </p>
<p>Loads of some assets, such as textures, can be batched in a bit asynchronous load. This allows you to continue setting up your game as assets are loaded, in the background.</p>
<p>Loading assets such as meshes will trigger the load of dependent assets such as textures. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afdafe317e19f70e8879368b699d070f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#afdafe317e19f70e8879368b699d070f7">AssetManager</a> (<a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;<a class="el" href="classfplbase_1_1_asset_manager.html#af9cc134e7699fb26452ea30ea34d73a6">renderer</a>)</td></tr>
<tr class="memdesc:afdafe317e19f70e8879368b699d070f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfplbase_1_1_asset_manager.html" title="Central place to own game assets loaded from disk. ">AssetManager</a> constructor.  <a href="#afdafe317e19f70e8879368b699d070f7">More...</a><br /></td></tr>
<tr class="separator:afdafe317e19f70e8879368b699d070f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f0b4670bfdf0fbf7c36552fcd8c55f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f0b4670bfdf0fbf7c36552fcd8c55f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a32f0b4670bfdf0fbf7c36552fcd8c55f">~AssetManager</a> ()</td></tr>
<tr class="memdesc:a32f0b4670bfdf0fbf7c36552fcd8c55f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfplbase_1_1_asset_manager.html" title="Central place to own game assets loaded from disk. ">AssetManager</a> destructor that purges all assets. <br /></td></tr>
<tr class="separator:a32f0b4670bfdf0fbf7c36552fcd8c55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba688065de01a8a8b857d6fcedee287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_shader.html">Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a6ba688065de01a8a8b857d6fcedee287">FindShader</a> (const char *basename)</td></tr>
<tr class="memdesc:a6ba688065de01a8a8b857d6fcedee287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previously loaded shader object.  <a href="#a6ba688065de01a8a8b857d6fcedee287">More...</a><br /></td></tr>
<tr class="separator:a6ba688065de01a8a8b857d6fcedee287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab346a315d0d202603a92cd3622428999"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_shader.html">Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#ab346a315d0d202603a92cd3622428999">LoadShader</a> (const char *basename)</td></tr>
<tr class="memdesc:ab346a315d0d202603a92cd3622428999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and returns a shader object.  <a href="#ab346a315d0d202603a92cd3622428999">More...</a><br /></td></tr>
<tr class="separator:ab346a315d0d202603a92cd3622428999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf52356fff526f1c67dc6f9d377189d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_shader.html">Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a7cf52356fff526f1c67dc6f9d377189d">LoadShader</a> (const char *basename, const char **defines)</td></tr>
<tr class="memdesc:a7cf52356fff526f1c67dc6f9d377189d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and returns a shader object with pre-defined identifiers.  <a href="#a7cf52356fff526f1c67dc6f9d377189d">More...</a><br /></td></tr>
<tr class="separator:a7cf52356fff526f1c67dc6f9d377189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22318090bef50ba8927ec4a77020a6e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_shader.html">Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a22318090bef50ba8927ec4a77020a6e1">ReloadShader</a> (const char *basename, const char **defines)</td></tr>
<tr class="memdesc:a22318090bef50ba8927ec4a77020a6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force a shader to reload.  <a href="#a22318090bef50ba8927ec4a77020a6e1">More...</a><br /></td></tr>
<tr class="separator:a22318090bef50ba8927ec4a77020a6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f174427ec4bd48cc53af8a8c289f2aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_shader.html">Shader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a4f174427ec4bd48cc53af8a8c289f2aa">LoadShaderDef</a> (const char *filename)</td></tr>
<tr class="memdesc:a4f174427ec4bd48cc53af8a8c289f2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a shader built by shader_pipeline.  <a href="#a4f174427ec4bd48cc53af8a8c289f2aa">More...</a><br /></td></tr>
<tr class="separator:a4f174427ec4bd48cc53af8a8c289f2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a25279dd4f29bca37729ffeb84a4c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#ab8a25279dd4f29bca37729ffeb84a4c2">UnloadShader</a> (const char *filename)</td></tr>
<tr class="memdesc:ab8a25279dd4f29bca37729ffeb84a4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the previously loaded shader.  <a href="#ab8a25279dd4f29bca37729ffeb84a4c2">More...</a><br /></td></tr>
<tr class="separator:ab8a25279dd4f29bca37729ffeb84a4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdabb2dc62c8426d526cad985f8bede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_texture.html">Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a5fdabb2dc62c8426d526cad985f8bede">FindTexture</a> (const char *filename)</td></tr>
<tr class="memdesc:a5fdabb2dc62c8426d526cad985f8bede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previously created texture.  <a href="#a5fdabb2dc62c8426d526cad985f8bede">More...</a><br /></td></tr>
<tr class="separator:a5fdabb2dc62c8426d526cad985f8bede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f96a94cf9dcfa7b4eddee79d425125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_texture.html">Texture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a85f96a94cf9dcfa7b4eddee79d425125">LoadTexture</a> (const char *filename, <a class="el" href="group__fplbase__texture.html#ga855ebc6f288537e9ffb45bddee48fdd3">TextureFormat</a> format=<a class="el" href="group__fplbase__texture.html#gga855ebc6f288537e9ffb45bddee48fdd3acc9f4197931d22a4cd70a52221c6e7e8">kFormatAuto</a>, bool mipmaps=true, bool async=true)</td></tr>
<tr class="memdesc:a85f96a94cf9dcfa7b4eddee79d425125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue loading a texture if it hasn't been loaded already.  <a href="#a85f96a94cf9dcfa7b4eddee79d425125">More...</a><br /></td></tr>
<tr class="separator:a85f96a94cf9dcfa7b4eddee79d425125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f1f7f56d270cf9f697fb949070bb9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a86f1f7f56d270cf9f697fb949070bb9d">StartLoadingTextures</a> ()</td></tr>
<tr class="memdesc:a86f1f7f56d270cf9f697fb949070bb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start loading all previously queued textures.  <a href="#a86f1f7f56d270cf9f697fb949070bb9d">More...</a><br /></td></tr>
<tr class="separator:a86f1f7f56d270cf9f697fb949070bb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29c7b975117946ee6c75dbb970909d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#ae29c7b975117946ee6c75dbb970909d6">TryFinalize</a> ()</td></tr>
<tr class="memdesc:ae29c7b975117946ee6c75dbb970909d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for the status of async loading textures.  <a href="#ae29c7b975117946ee6c75dbb970909d6">More...</a><br /></td></tr>
<tr class="separator:ae29c7b975117946ee6c75dbb970909d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcff6c34a1effd91b71deca62301525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a3bcff6c34a1effd91b71deca62301525">UnloadTexture</a> (const char *filename)</td></tr>
<tr class="memdesc:a3bcff6c34a1effd91b71deca62301525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the previously loaded texture.  <a href="#a3bcff6c34a1effd91b71deca62301525">More...</a><br /></td></tr>
<tr class="separator:a3bcff6c34a1effd91b71deca62301525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d1c2460155a0ae1fedf3efd4952921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_material.html">Material</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a32d1c2460155a0ae1fedf3efd4952921">FindMaterial</a> (const char *filename)</td></tr>
<tr class="memdesc:a32d1c2460155a0ae1fedf3efd4952921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previously loaded material.  <a href="#a32d1c2460155a0ae1fedf3efd4952921">More...</a><br /></td></tr>
<tr class="separator:a32d1c2460155a0ae1fedf3efd4952921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eacd8eccf4b4d76167866c94019584a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_material.html">Material</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a3eacd8eccf4b4d76167866c94019584a">LoadMaterial</a> (const char *filename)</td></tr>
<tr class="memdesc:a3eacd8eccf4b4d76167866c94019584a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and returns a material object.  <a href="#a3eacd8eccf4b4d76167866c94019584a">More...</a><br /></td></tr>
<tr class="separator:a3eacd8eccf4b4d76167866c94019584a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35aaff069175c34f7098677cc488160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#ad35aaff069175c34f7098677cc488160">UnloadMaterial</a> (const char *filename)</td></tr>
<tr class="memdesc:ad35aaff069175c34f7098677cc488160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the previously loaded material.  <a href="#ad35aaff069175c34f7098677cc488160">More...</a><br /></td></tr>
<tr class="separator:ad35aaff069175c34f7098677cc488160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22997f76b3142bddd798a33c1afefcce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a22997f76b3142bddd798a33c1afefcce">FindMesh</a> (const char *filename)</td></tr>
<tr class="memdesc:a22997f76b3142bddd798a33c1afefcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a previously loaded mesh.  <a href="#a22997f76b3142bddd798a33c1afefcce">More...</a><br /></td></tr>
<tr class="separator:a22997f76b3142bddd798a33c1afefcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c11f9d452aa6c206a83c6da6b19ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#ac8c11f9d452aa6c206a83c6da6b19ed4">LoadMesh</a> (const char *filename)</td></tr>
<tr class="memdesc:ac8c11f9d452aa6c206a83c6da6b19ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and returns a mesh object.  <a href="#ac8c11f9d452aa6c206a83c6da6b19ed4">More...</a><br /></td></tr>
<tr class="separator:ac8c11f9d452aa6c206a83c6da6b19ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734c399e3160e73f6b2c3bcd22d63ebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a734c399e3160e73f6b2c3bcd22d63ebd">UnloadMesh</a> (const char *filename)</td></tr>
<tr class="memdesc:a734c399e3160e73f6b2c3bcd22d63ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the previously loaded mesh.  <a href="#a734c399e3160e73f6b2c3bcd22d63ebd">More...</a><br /></td></tr>
<tr class="separator:a734c399e3160e73f6b2c3bcd22d63ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4c1b9f851f0d68ed189b66d6ae97d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_texture_atlas.html">TextureAtlas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a6a4c1b9f851f0d68ed189b66d6ae97d5">FindTextureAtlas</a> (const char *filename)</td></tr>
<tr class="memdesc:a6a4c1b9f851f0d68ed189b66d6ae97d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a previously loaded texture atlas.  <a href="#a6a4c1b9f851f0d68ed189b66d6ae97d5">More...</a><br /></td></tr>
<tr class="separator:a6a4c1b9f851f0d68ed189b66d6ae97d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e78ff2e874be1b8d9546cb57ec1f9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_texture_atlas.html">TextureAtlas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a8e78ff2e874be1b8d9546cb57ec1f9fb">LoadTextureAtlas</a> (const char *filename)</td></tr>
<tr class="memdesc:a8e78ff2e874be1b8d9546cb57ec1f9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a texture atlas.  <a href="#a8e78ff2e874be1b8d9546cb57ec1f9fb">More...</a><br /></td></tr>
<tr class="separator:a8e78ff2e874be1b8d9546cb57ec1f9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08114d815e6f9a84e05fac37958291eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a08114d815e6f9a84e05fac37958291eb">UnloadTextureAtlas</a> (const char *filename)</td></tr>
<tr class="memdesc:a08114d815e6f9a84e05fac37958291eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a texture atlas and remove it from the asset manager.  <a href="#a08114d815e6f9a84e05fac37958291eb">More...</a><br /></td></tr>
<tr class="separator:a08114d815e6f9a84e05fac37958291eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c95ae3ee2e7253302f1cc52a8765dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_file_asset.html">FileAsset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a54c95ae3ee2e7253302f1cc52a8765dc">FindFileAsset</a> (const char *filename)</td></tr>
<tr class="memdesc:a54c95ae3ee2e7253302f1cc52a8765dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a previously loaded file asset.  <a href="#a54c95ae3ee2e7253302f1cc52a8765dc">More...</a><br /></td></tr>
<tr class="separator:a54c95ae3ee2e7253302f1cc52a8765dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7e71d7b7a5de77fa42143cac6611c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_file_asset.html">FileAsset</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#abe7e71d7b7a5de77fa42143cac6611c0">LoadFileAsset</a> (const char *filename)</td></tr>
<tr class="memdesc:abe7e71d7b7a5de77fa42143cac6611c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a file asset.  <a href="#abe7e71d7b7a5de77fa42143cac6611c0">More...</a><br /></td></tr>
<tr class="separator:abe7e71d7b7a5de77fa42143cac6611c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc502fb88e2a10d1993cab81d51d3fde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#afc502fb88e2a10d1993cab81d51d3fde">UnloadFileAsset</a> (const char *filename)</td></tr>
<tr class="memdesc:afc502fb88e2a10d1993cab81d51d3fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file asset and remove it from the asset manager.  <a href="#afc502fb88e2a10d1993cab81d51d3fde">More...</a><br /></td></tr>
<tr class="separator:afc502fb88e2a10d1993cab81d51d3fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cc134e7699fb26452ea30ea34d73a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#af9cc134e7699fb26452ea30ea34d73a6">renderer</a> ()</td></tr>
<tr class="memdesc:af9cc134e7699fb26452ea30ea34d73a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy accessor for the renderer.  <a href="#af9cc134e7699fb26452ea30ea34d73a6">More...</a><br /></td></tr>
<tr class="separator:af9cc134e7699fb26452ea30ea34d73a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff4bca45d52a44045decb3b38b6ed7f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#a8ff4bca45d52a44045decb3b38b6ed7f">renderer</a> () const </td></tr>
<tr class="memdesc:a8ff4bca45d52a44045decb3b38b6ed7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handy accessor for the renderer.  <a href="#a8ff4bca45d52a44045decb3b38b6ed7f">More...</a><br /></td></tr>
<tr class="separator:a8ff4bca45d52a44045decb3b38b6ed7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace320048b6c3d64666b13158413cd27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#ace320048b6c3d64666b13158413cd27a">ClearAllAssets</a> ()</td></tr>
<tr class="memdesc:ace320048b6c3d64666b13158413cd27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and destructs all assets held by the <a class="el" href="classfplbase_1_1_asset_manager.html" title="Central place to own game assets loaded from disk. ">AssetManager</a>.  <a href="#ace320048b6c3d64666b13158413cd27a">More...</a><br /></td></tr>
<tr class="separator:ace320048b6c3d64666b13158413cd27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf11c53b9f9d83ae18e003e5283e39ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset_manager.html#acf11c53b9f9d83ae18e003e5283e39ff">SetTextureScale</a> (const mathfu::vec2 &amp;scale)</td></tr>
<tr class="memdesc:acf11c53b9f9d83ae18e003e5283e39ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a scaling factor to apply when loading texture materials.  <a href="#acf11c53b9f9d83ae18e003e5283e39ff">More...</a><br /></td></tr>
<tr class="separator:acf11c53b9f9d83ae18e003e5283e39ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afdafe317e19f70e8879368b699d070f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fplbase::AssetManager::AssetManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classfplbase_1_1_asset_manager.html" title="Central place to own game assets loaded from disk. ">AssetManager</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">renderer</td><td>A reference to the <a class="el" href="classfplbase_1_1_renderer.html" title="Manages the rendering system, handling the window and resources. ">Renderer</a> to use with the <a class="el" href="classfplbase_1_1_asset_manager.html" title="Central place to own game assets loaded from disk. ">AssetManager</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ace320048b6c3d64666b13158413cd27a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::ClearAllAssets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and destructs all assets held by the <a class="el" href="classfplbase_1_1_asset_manager.html" title="Central place to own game assets loaded from disk. ">AssetManager</a>. </p>
<p>Will be called automatically by the destructor, but can also be called manually beforehand if necessary since destructing assets requires the OpenGL context to still be alive. </p>

</div>
</div>
<a class="anchor" id="a54c95ae3ee2e7253302f1cc52a8765dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_file_asset.html">FileAsset</a>* fplbase::AssetManager::FindFileAsset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a previously loaded file asset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the file asset file to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the file asset if found, nullptr otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a32d1c2460155a0ae1fedf3efd4952921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_material.html">Material</a>* fplbase::AssetManager::FindMaterial </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a previously loaded material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the material. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the material, or nullptr if not previously loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a22997f76b3142bddd798a33c1afefcce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_mesh.html">Mesh</a>* fplbase::AssetManager::FindMesh </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a previously loaded mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mesh, or nullptr if not previously loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ba688065de01a8a8b857d6fcedee287"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_shader.html">Shader</a>* fplbase::AssetManager::FindShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a previously loaded shader object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basename</td><td>The name of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the shader, or nullptr if not previously loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a5fdabb2dc62c8426d526cad985f8bede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_texture.html">Texture</a>* fplbase::AssetManager::FindTexture </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a previously created texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the texture, or nullptr if not previously loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a4c1b9f851f0d68ed189b66d6ae97d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_texture_atlas.html">TextureAtlas</a>* fplbase::AssetManager::FindTextureAtlas </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a previously loaded texture atlas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the texture atlas file to look up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the texture atlas if found, nullptr otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abe7e71d7b7a5de77fa42143cac6611c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_file_asset.html">FileAsset</a>* fplbase::AssetManager::LoadFileAsset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a file asset. </p>
<dl class="section return"><dt>Returns</dt><dd>nullptr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a3eacd8eccf4b4d76167866c94019584a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_material.html">Material</a>* fplbase::AssetManager::LoadMaterial </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and returns a material object. </p>
<p>Loads a material, which is a compiled FlatBuffer file with root <a class="el" href="classfplbase_1_1_material.html" title="Collections of textures used for rendering multi-texture models. ">Material</a>. This loads all resources contained there-in. If this returns nullptr, the error can be found in <a class="el" href="classfplbase_1_1_renderer.html#a8270278372c6931667f22f0ced92d1aa" title="Contains the last error that occurred, if there is one. ">Renderer::last_error()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the material. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the loaded material, or nullptr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8c11f9d452aa6c206a83c6da6b19ed4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_mesh.html">Mesh</a>* fplbase::AssetManager::LoadMesh </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and returns a mesh object. </p>
<p>Loads a mesh, which is a compiled FlatBuffer file with root <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a>. If this returns nullptr, the error can be found in <a class="el" href="classfplbase_1_1_renderer.html#a8270278372c6931667f22f0ced92d1aa" title="Contains the last error that occurred, if there is one. ">Renderer::last_error()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab346a315d0d202603a92cd3622428999"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_shader.html">Shader</a>* fplbase::AssetManager::LoadShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and returns a shader object. </p>
<p>Loads a shader if it hasn't been loaded already, by appending .glslv and .glslf to the basename, compiling and linking them. If this returns nullptr, the error can be found in <a class="el" href="classfplbase_1_1_renderer.html#a8270278372c6931667f22f0ced92d1aa" title="Contains the last error that occurred, if there is one. ">Renderer::last_error()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basename</td><td>The name of the shader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the loaded shader, or nullptr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cf52356fff526f1c67dc6f9d377189d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_shader.html">Shader</a>* fplbase::AssetManager::LoadShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>defines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads and returns a shader object with pre-defined identifiers. </p>
<p>Works like LoadShader (above), but takes in a set of #define variables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basename</td><td>The name of the shader. </td></tr>
    <tr><td class="paramname">defines</td><td>A null-terminated array of variables to #define, or nullptr if there are no initial #define variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>An example of how to create such an array: static const char *kMyDefines[] = { USE_SHADOWS, USE_THE_FORCE, USE_SOMEBODY, nullptr }; </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the loaded shader, or nullptr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f174427ec4bd48cc53af8a8c289f2aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_shader.html">Shader</a>* fplbase::AssetManager::LoadShaderDef </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a shader built by shader_pipeline. </p>
<p>Loads a shader built by the shader_pipeline if it hasn't been loaded. already. If this returns nullptr, the error can be found in <a class="el" href="classfplbase_1_1_renderer.html#a8270278372c6931667f22f0ced92d1aa" title="Contains the last error that occurred, if there is one. ">Renderer::last_error()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the shader file to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the loaded shader, or nullptr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a85f96a94cf9dcfa7b4eddee79d425125"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_texture.html">Texture</a>* fplbase::AssetManager::LoadTexture </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fplbase__texture.html#ga855ebc6f288537e9ffb45bddee48fdd3">TextureFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="group__fplbase__texture.html#gga855ebc6f288537e9ffb45bddee48fdd3acc9f4197931d22a4cd70a52221c6e7e8">kFormatAuto</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mipmaps</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue loading a texture if it hasn't been loaded already. </p>
<p>If async, queues a texture for loading if it hasn't been loaded already, otherwise loads it directly. Currently only supports TGA/WebP format files. If async, the returned texture isn't usable until <a class="el" href="classfplbase_1_1_asset_manager.html#ae29c7b975117946ee6c75dbb970909d6" title="Check for the status of async loading textures. ">TryFinalize()</a> succeeds and the id is non-zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the texture to load. </td></tr>
    <tr><td class="paramname">format</td><td>The texture format, defaults to kFormatAuto. </td></tr>
    <tr><td class="paramname">mipmaps</td><td>If mipmaps should be used, defaults to true. </td></tr>
    <tr><td class="paramname">async</td><td>Whether to load the texture asynchronously. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns an unloaded texture object. If not async, may also return null to signal and error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e78ff2e874be1b8d9546cb57ec1f9fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_texture_atlas.html">TextureAtlas</a>* fplbase::AssetManager::LoadTextureAtlas </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a texture atlas. </p>
<p>Loads a texture atlas, which is a compiled FlatBuffer file containing a texture path and subtexture rectangles.</p>
<dl class="section return"><dt>Returns</dt><dd>If this returns nullptr, the error can be found in <a class="el" href="classfplbase_1_1_renderer.html#a8270278372c6931667f22f0ced92d1aa" title="Contains the last error that occurred, if there is one. ">Renderer::last_error()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a22318090bef50ba8927ec4a77020a6e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_shader.html">Shader</a>* fplbase::AssetManager::ReloadShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>defines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force a shader to reload. </p>
<p>Regardless of whether the shader has been loaded previously, the shader will recompile. Otherwise works like LoadShader (above).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basename</td><td>The name of the shader. </td></tr>
    <tr><td class="paramname">defines</td><td>A null-terminated array of variables to #define, or nullptr if there are no initial #define variables. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the loaded shader, or nullptr if there was an error. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If this function doesn't return nullptr, the pointer will be equal to any previous (Re)LoadShader calls. </dd></dl>

</div>
</div>
<a class="anchor" id="af9cc134e7699fb26452ea30ea34d73a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_renderer.html">Renderer</a>&amp; fplbase::AssetManager::renderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handy accessor for the renderer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the renderer. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ff4bca45d52a44045decb3b38b6ed7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classfplbase_1_1_renderer.html">Renderer</a>&amp; fplbase::AssetManager::renderer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handy accessor for the renderer. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the renderer. </dd></dl>

</div>
</div>
<a class="anchor" id="acf11c53b9f9d83ae18e003e5283e39ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::SetTextureScale </td>
          <td>(</td>
          <td class="paramtype">const mathfu::vec2 &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a scaling factor to apply when loading texture materials. </p>
<p>By setting the scaling factor, an application save a memory footprint on low RAM devices. </p>

</div>
</div>
<a class="anchor" id="a86f1f7f56d270cf9f697fb949070bb9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::StartLoadingTextures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start loading all previously queued textures. </p>
<p>LoadTextures doesn't actually load anything, this will start the async loading of all files, and decompression. </p>

</div>
</div>
<a class="anchor" id="ae29c7b975117946ee6c75dbb970909d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fplbase::AssetManager::TryFinalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for the status of async loading textures. </p>
<p>Call this repeatedly until it returns true, which signals all textures will have loaded, and turned into OpenGL textures. Textures with a 0 id will have failed to load.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true when all textures have been loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="afc502fb88e2a10d1993cab81d51d3fde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::UnloadFileAsset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a file asset and remove it from the asset manager. </p>
<p>If its reference count was &gt;1, it will be decreased instead of unloaded. </p>

</div>
</div>
<a class="anchor" id="ad35aaff069175c34f7098677cc488160"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::UnloadMaterial </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the previously loaded material. </p>
<p>Deletes all OpenGL textures contained in this material, and removes the textures and the material from material manager. Any subsequent requests for these textures through Load*() will cause them to be loaded anew. If its reference count was &gt;1, it will be decreased instead of unloaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the material to unload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a734c399e3160e73f6b2c3bcd22d63ebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::UnloadMesh </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the previously loaded mesh. </p>
<p>Deletes the mesh and removes it from the material manager. Any subsequent requests for this mesh through Load*() will cause them to be loaded anew. If its reference count was &gt;1, it will be decreased instead of unloaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the mesh to unload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8a25279dd4f29bca37729ffeb84a4c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::UnloadShader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the previously loaded shader. </p>
<p>Deletes the shader and removes it from the material manager. Any subsequent requests for this shader through Load*() will cause them to be loaded anew. If its reference count was &gt;1, it will be decreased instead of unloaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the shader to unload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bcff6c34a1effd91b71deca62301525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::UnloadTexture </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the previously loaded texture. </p>
<p>Deletes the texture and removes it from the material manager. Any subsequent requests for this mesh through Load*() will cause them to be loaded anew. If its reference count was &gt;1, it will be decreased instead of unloaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the texture to unload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08114d815e6f9a84e05fac37958291eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::AssetManager::UnloadTextureAtlas </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a texture atlas and remove it from the asset manager. </p>
<p>This will cause any <a class="el" href="classfplbase_1_1_texture.html" title="Abstraction for a texture object loaded on the GPU. ">Texture</a> objects this atlas has issued to no longer refer to a valid texture. Any subsequent requests for this texture atlas through Load*() will cause it to be loaded anew. If its reference count was &gt;1, it will be decreased instead of unloaded. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="asset__manager_8h_source.html">asset_manager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-49880327-7', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>
