<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>FPLBase: fplbase::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
<script>
  /**
   * Check if the browser rendering this page is being run on an Android device.
   * It checks if the string 'android' is found in the browser's `userAgent`.
   * @return {boolean} This returns `true` if the browser's `userAgent` contains
   * the string 'android' (indicating that the browser is on an Android device).
   * Otherwise, it returns `false`.
   */
  function isAndroidDevice() {
    if (navigator && navigator.userAgent) {
      return navigator.userAgent.toLowerCase().indexOf('android') != -1;
    } else {
      return false;
    }
  }
  /**
   * Check if an HTML `class` attribute is in the browser-specific format.
   * @param {string} An HTML `class` attribute in the format 'browser-{device}'.
   * @return {boolean} Returns `true` if `browserClass` was in the valid format,
   * prefixed with 'browser-'. Otherwise, it returns false.
   */
  function isBrowserSpecificClassName(browserClass) {
    if (browserClass && browserClass.substring(0, 8) == 'browser-' &&
        browserClass.length > 8) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Get all the HTML Elements with browser-specific `class` attributes.
   * @return {array} Returns an array of all the HTML Elements with a `class`
   * attribute that is prefixed with `browser-`.
   */
  function getAllBrowserSpecificElements() {
    if (document) {
      var htmlElements = document.getElementsByTagName("*");
      var browserSpecificElements = [];
      for (var i = 0; i < htmlElements.length; i++) {
        if (isBrowserSpecificClassName(htmlElements[i].className)) {
          browserSpecificElements.push(htmlElements[i]);
        }
      }
      return browserSpecificElements;
    } else {
      return null;
    }
  }
  /**
   * Given a browser-specific HTML `class` attribute, extract the device name.
   * @param {string} browserClass The string name of an HTML `class` attribute,
   * in the format `browser-{device}`.
   * @return {string} Returns a string containing only the device portion of
   * the class name. If the input was invalid, then it returns `null`.
   */
  function extractDeviceFromBrowserClass(browserClass) {
    if (isBrowserSpecificClassName(browserClass)) {
      return browserClass.substring(8);
    }
    else {
      return null;
    }
  }
  /**
   * Hide device specific elements that do not apply to the current device.
   */
  function handleDeviceSpecificLoading() {
    var browserSpecificElements = getAllBrowserSpecificElements();
    for (var i = 0; i < browserSpecificElements.length; i++) {
      var device = extractDeviceFromBrowserClass(browserSpecificElements[i].className);
      if (device && !isAndroidDevice() && device == 'android') {
        browserSpecificElements[i].innerHTML = '';
      } else if(device && isAndroidDevice() && device == 'desktop') {
        browserSpecificElements[i].innerHTML = '';
      }
    }
  }
  $(document).ready(handleDeviceSpecificLoading);
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FPLBase
   </div>
   <div style="font-size:12px;">
	 An open source project by
     <a href="https://developers.google.com/games/#Tools">FPL</a>.
  </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer's&#160;Guide</span></a></li>
      <li class="current"><a href="fplbase_api_reference.html"><span>API&#160;reference</span></a></li>
      <li><a href="contributing.html"><span>Contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfplbase_1_1_mesh.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfplbase_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fplbase::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstraction for a set of indices, used for rendering.  
 <a href="classfplbase_1_1_mesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mesh_8h_source.html">mesh.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstraction for a set of indices, used for rendering. </p>
<p>A mesh instance contains a VBO and one or more IBO's. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abd19aac0cef94b0fb47035805e3c02d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Primitive</b> { <b>kTriangles</b>, 
<b>kLines</b>
 }</td></tr>
<tr class="separator:abd19aac0cef94b0fb47035805e3c02d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a1a13a9d08c50084ddd354160bd84b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>kAttributePosition</b>, 
<b>kAttributeNormal</b>, 
<b>kAttributeTangent</b>, 
<b>kAttributeTexCoord</b>, 
<br/>
&#160;&#160;<b>kAttributeColor</b>, 
<b>kAttributeBoneIndices</b>, 
<b>kAttributeBoneWeights</b>
<br/>
 }</td></tr>
<tr class="separator:a91a1a13a9d08c50084ddd354160bd84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7d39bd182fdecbca37c1f84a5d423a41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d39bd182fdecbca37c1f84a5d423a41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a7d39bd182fdecbca37c1f84a5d423a41">Mesh</a> (const void *vertex_data, int count, int vertex_size, const Attribute *format, mathfu::vec3 *<a class="el" href="classfplbase_1_1_mesh.html#a1897261b1050950e6d650c19cd28332d">max_position</a>=nullptr, mathfu::vec3 *<a class="el" href="classfplbase_1_1_mesh.html#add6031658ca8b8eb900bd5c63a215d29">min_position</a>=nullptr)</td></tr>
<tr class="memdesc:a7d39bd182fdecbca37c1f84a5d423a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> by creating one VBO, and no IBO's. <br/></td></tr>
<tr class="separator:a7d39bd182fdecbca37c1f84a5d423a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52dec90de14938c3d40ab39dd41a96ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a52dec90de14938c3d40ab39dd41a96ee">AddIndices</a> (const unsigned short *indices, int count, <a class="el" href="classfplbase_1_1_material.html">Material</a> *mat)</td></tr>
<tr class="memdesc:a52dec90de14938c3d40ab39dd41a96ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an index buffer object to be part of this mesh.  <a href="#a52dec90de14938c3d40ab39dd41a96ee">More...</a><br/></td></tr>
<tr class="separator:a52dec90de14938c3d40ab39dd41a96ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f787785d01d9dd731624d3bcef6362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#ad1f787785d01d9dd731624d3bcef6362">SetBones</a> (const mathfu::AffineTransform *<a class="el" href="classfplbase_1_1_mesh.html#ad675b3b094f0fb747a5b0cc7f7dd4bd8">bone_transforms</a>, const uint8_t *<a class="el" href="classfplbase_1_1_mesh.html#a8ba887b02a8a87eb6060a613eb5d9c05">bone_parents</a>, const char **bone_names, size_t <a class="el" href="classfplbase_1_1_mesh.html#af9e5bcb4f1b14a51fab19dfa924b868a">num_bones</a>, const uint8_t *<a class="el" href="classfplbase_1_1_mesh.html#a5aeaa120faafcf24302e1399f50eb4ca">shader_bone_indices</a>, size_t <a class="el" href="classfplbase_1_1_mesh.html#aa440c5b19f40c3719c73e7c1e86b7bdd">num_shader_bones</a>)</td></tr>
<tr class="memdesc:ad1f787785d01d9dd731624d3bcef6362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bones used by an animated mesh.  <a href="#ad1f787785d01d9dd731624d3bcef6362">More...</a><br/></td></tr>
<tr class="separator:ad1f787785d01d9dd731624d3bcef6362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534ad4d50aec1afdbf649d7831d5ddd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a534ad4d50aec1afdbf649d7831d5ddd1">GatherShaderTransforms</a> (const mathfu::AffineTransform *<a class="el" href="classfplbase_1_1_mesh.html#ad675b3b094f0fb747a5b0cc7f7dd4bd8">bone_transforms</a>, mathfu::AffineTransform *shader_transforms) const </td></tr>
<tr class="memdesc:a534ad4d50aec1afdbf649d7831d5ddd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts bone transforms to eliminate the bones that have no verts weighted to them.  <a href="#a534ad4d50aec1afdbf649d7831d5ddd1">More...</a><br/></td></tr>
<tr class="separator:a534ad4d50aec1afdbf649d7831d5ddd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552626bc96b1686f4f5ed44718995f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a552626bc96b1686f4f5ed44718995f4f">Render</a> (<a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;renderer, bool ignore_material=false, size_t instances=1)</td></tr>
<tr class="memdesc:a552626bc96b1686f4f5ed44718995f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render the mesh.  <a href="#a552626bc96b1686f4f5ed44718995f4f">More...</a><br/></td></tr>
<tr class="separator:a552626bc96b1686f4f5ed44718995f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc0021f5ed18b5cf52b9aa9268a576a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacc0021f5ed18b5cf52b9aa9268a576a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RenderStereo</b> (<a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;renderer, const <a class="el" href="classfplbase_1_1_shader.html">Shader</a> *shader, const mathfu::vec4i *viewport, const mathfu::mat4 *mvp, const mathfu::vec3 *camera_position, bool ignore_material=false, size_t instances=1)</td></tr>
<tr class="separator:aacc0021f5ed18b5cf52b9aa9268a576a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d9c1b83bbd142547c749775c2f6287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_material.html">Material</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#ac7d9c1b83bbd142547c749775c2f6287">GetMaterial</a> (int i)</td></tr>
<tr class="memdesc:ac7d9c1b83bbd142547c749775c2f6287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the material associated with the IBO at the given index.  <a href="#ac7d9c1b83bbd142547c749775c2f6287">More...</a><br/></td></tr>
<tr class="separator:ac7d9c1b83bbd142547c749775c2f6287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99db7c679fa5afbdc4e17cdeb30eaa7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a99db7c679fa5afbdc4e17cdeb30eaa7e">set_format</a> (const Attribute *format)</td></tr>
<tr class="memdesc:a99db7c679fa5afbdc4e17cdeb30eaa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the vertex buffer format.  <a href="#a99db7c679fa5afbdc4e17cdeb30eaa7e">More...</a><br/></td></tr>
<tr class="separator:a99db7c679fa5afbdc4e17cdeb30eaa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6031658ca8b8eb900bd5c63a215d29"><td class="memItemLeft" align="right" valign="top">const mathfu::vec3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#add6031658ca8b8eb900bd5c63a215d29">min_position</a> () const </td></tr>
<tr class="memdesc:add6031658ca8b8eb900bd5c63a215d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum position of an AABB about the mesh.  <a href="#add6031658ca8b8eb900bd5c63a215d29">More...</a><br/></td></tr>
<tr class="separator:add6031658ca8b8eb900bd5c63a215d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1897261b1050950e6d650c19cd28332d"><td class="memItemLeft" align="right" valign="top">const mathfu::vec3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a1897261b1050950e6d650c19cd28332d">max_position</a> () const </td></tr>
<tr class="memdesc:a1897261b1050950e6d650c19cd28332d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum position of an AABB about the mesh.  <a href="#a1897261b1050950e6d650c19cd28332d">More...</a><br/></td></tr>
<tr class="separator:a1897261b1050950e6d650c19cd28332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad675b3b094f0fb747a5b0cc7f7dd4bd8"><td class="memItemLeft" align="right" valign="top">const mathfu::AffineTransform *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#ad675b3b094f0fb747a5b0cc7f7dd4bd8">bone_transforms</a> () const </td></tr>
<tr class="memdesc:ad675b3b094f0fb747a5b0cc7f7dd4bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relative transforms of the bones.  <a href="#ad675b3b094f0fb747a5b0cc7f7dd4bd8">More...</a><br/></td></tr>
<tr class="separator:ad675b3b094f0fb747a5b0cc7f7dd4bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756ec40f9d50a2e1490e2f51de9de591"><td class="memItemLeft" align="right" valign="top">const mathfu::AffineTransform *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a756ec40f9d50a2e1490e2f51de9de591">bone_global_transforms</a> () const </td></tr>
<tr class="memdesc:a756ec40f9d50a2e1490e2f51de9de591"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global transforms of the bones (taking into account parents).  <a href="#a756ec40f9d50a2e1490e2f51de9de591">More...</a><br/></td></tr>
<tr class="separator:a756ec40f9d50a2e1490e2f51de9de591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba887b02a8a87eb6060a613eb5d9c05"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a8ba887b02a8a87eb6060a613eb5d9c05">bone_parents</a> () const </td></tr>
<tr class="memdesc:a8ba887b02a8a87eb6060a613eb5d9c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The defines parents of each bone.  <a href="#a8ba887b02a8a87eb6060a613eb5d9c05">More...</a><br/></td></tr>
<tr class="separator:a8ba887b02a8a87eb6060a613eb5d9c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e5bcb4f1b14a51fab19dfa924b868a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#af9e5bcb4f1b14a51fab19dfa924b868a">num_bones</a> () const </td></tr>
<tr class="memdesc:af9e5bcb4f1b14a51fab19dfa924b868a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bones in the mesh.  <a href="#af9e5bcb4f1b14a51fab19dfa924b868a">More...</a><br/></td></tr>
<tr class="separator:af9e5bcb4f1b14a51fab19dfa924b868a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aeaa120faafcf24302e1399f50eb4ca"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a5aeaa120faafcf24302e1399f50eb4ca">shader_bone_indices</a> () const </td></tr>
<tr class="memdesc:a5aeaa120faafcf24302e1399f50eb4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indices of bones used by the shader.  <a href="#a5aeaa120faafcf24302e1399f50eb4ca">More...</a><br/></td></tr>
<tr class="separator:a5aeaa120faafcf24302e1399f50eb4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa440c5b19f40c3719c73e7c1e86b7bdd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#aa440c5b19f40c3719c73e7c1e86b7bdd">num_shader_bones</a> () const </td></tr>
<tr class="memdesc:aa440c5b19f40c3719c73e7c1e86b7bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bones used by the shader.  <a href="#aa440c5b19f40c3719c73e7c1e86b7bdd">More...</a><br/></td></tr>
<tr class="separator:aa440c5b19f40c3719c73e7c1e86b7bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7f7bfae0ab41c198e1d9843010e049bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a7f7bfae0ab41c198e1d9843010e049bf">RenderArray</a> (Primitive primitive, int index_count, const Attribute *format, int vertex_size, const void *vertices, const unsigned short *indices)</td></tr>
<tr class="memdesc:a7f7bfae0ab41c198e1d9843010e049bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the given vertex and index data directly.  <a href="#a7f7bfae0ab41c198e1d9843010e049bf">More...</a><br/></td></tr>
<tr class="separator:a7f7bfae0ab41c198e1d9843010e049bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af892718f24e323cd1fdf6f52e945d0d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#af892718f24e323cd1fdf6f52e945d0d2">RenderAAQuadAlongX</a> (const mathfu::vec3 &amp;bottom_left, const mathfu::vec3 &amp;top_right, const mathfu::vec2 &amp;tex_bottom_left=mathfu::vec2(0, 0), const mathfu::vec2 &amp;tex_top_right=mathfu::vec2(1, 1))</td></tr>
<tr class="memdesc:af892718f24e323cd1fdf6f52e945d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for rendering a Quad.  <a href="#af892718f24e323cd1fdf6f52e945d0d2">More...</a><br/></td></tr>
<tr class="separator:af892718f24e323cd1fdf6f52e945d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941da21a44789d08f972122633c356af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a941da21a44789d08f972122633c356af">RenderAAQuadAlongXNinePatch</a> (const mathfu::vec3 &amp;bottom_left, const mathfu::vec3 &amp;top_right, const mathfu::vec2i &amp;texture_size, const mathfu::vec4 &amp;patch_info)</td></tr>
<tr class="memdesc:a941da21a44789d08f972122633c356af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for rendering a Quad with nine patch settings.  <a href="#a941da21a44789d08f972122633c356af">More...</a><br/></td></tr>
<tr class="separator:a941da21a44789d08f972122633c356af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a432d7b64495f28648555104dd74bf0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a432d7b64495f28648555104dd74bf0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a9a432d7b64495f28648555104dd74bf0">ComputeNormalsTangents</a> (T *vertices, const unsigned short *indices, int numverts, int numindices)</td></tr>
<tr class="memdesc:a9a432d7b64495f28648555104dd74bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normals and tangents given position and texcoords.  <a href="#a9a432d7b64495f28648555104dd74bf0">More...</a><br/></td></tr>
<tr class="separator:a9a432d7b64495f28648555104dd74bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3db409ea671ecd2fdae87fc47cdb5fb"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#af3db409ea671ecd2fdae87fc47cdb5fb">VertexSize</a> (const Attribute *attributes, Attribute end=kEND)</td></tr>
<tr class="memdesc:af3db409ea671ecd2fdae87fc47cdb5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the byte size for a vertex from given attributes.  <a href="#af3db409ea671ecd2fdae87fc47cdb5fb">More...</a><br/></td></tr>
<tr class="separator:af3db409ea671ecd2fdae87fc47cdb5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a52dec90de14938c3d40ab39dd41a96ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::AddIndices </td>
          <td>(</td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfplbase_1_1_material.html">Material</a> *&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an index buffer object to be part of this mesh. </p>
<p>Create one IBO to be part of this mesh. May be called more than once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to be included in the IBO. </td></tr>
    <tr><td class="paramname">count</td><td>The number of indices. </td></tr>
    <tr><td class="paramname">mat</td><td>The material associated with the IBO. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a756ec40f9d50a2e1490e2f51de9de591"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const mathfu::AffineTransform* fplbase::Mesh::bone_global_transforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The global transforms of the bones (taking into account parents). </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an array of global transforms for the mesh's bones. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ba887b02a8a87eb6060a613eb5d9c05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* fplbase::Mesh::bone_parents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The defines parents of each bone. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an array of indices of each bone's parent. </dd></dl>

</div>
</div>
<a class="anchor" id="ad675b3b094f0fb747a5b0cc7f7dd4bd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const mathfu::AffineTransform* fplbase::Mesh::bone_transforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The relative transforms of the bones. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an array of transforms for the mesh's bones. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a432d7b64495f28648555104dd74bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::ComputeNormalsTangents </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numverts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numindices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute normals and tangents given position and texcoords. </p>
<p>The template type should be a struct with at least the following fields: mathfu::vec3_packed pos; mathfu::vec2_packed tc; mathfu::vec3_packed norm; mathfu::vec4_packed tangent;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vertices to computes the information for. </td></tr>
    <tr><td class="paramname">indices</td><td>The indices that make up the mesh. </td></tr>
    <tr><td class="paramname">numverts</td><td>The number of vertices in the vertex array. </td></tr>
    <tr><td class="paramname">numindices</td><td>The number of indices in the index array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a534ad4d50aec1afdbf649d7831d5ddd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::GatherShaderTransforms </td>
          <td>(</td>
          <td class="paramtype">const mathfu::AffineTransform *&#160;</td>
          <td class="paramname"><em>bone_transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mathfu::AffineTransform *&#160;</td>
          <td class="paramname"><em>shader_transforms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compacts bone transforms to eliminate the bones that have no verts weighted to them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bone_transforms</td><td>Input array of bones, should be of length <a class="el" href="classfplbase_1_1_mesh.html#af9e5bcb4f1b14a51fab19dfa924b868a" title="The number of bones in the mesh. ">num_bones()</a>. </td></tr>
    <tr><td class="paramname">shader_transforms</td><td>Output array of bones, should be of length <a class="el" href="classfplbase_1_1_mesh.html#aa440c5b19f40c3719c73e7c1e86b7bdd" title="The number of bones used by the shader. ">num_shader_bones()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7d9c1b83bbd142547c749775c2f6287"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_material.html">Material</a>* fplbase::Mesh::GetMaterial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the material associated with the IBO at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the IBO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the material of the corresponding IBO. </dd></dl>

</div>
</div>
<a class="anchor" id="a1897261b1050950e6d650c19cd28332d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const mathfu::vec3&amp; fplbase::Mesh::max_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum position of an AABB about the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum position of the mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="add6031658ca8b8eb900bd5c63a215d29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const mathfu::vec3&amp; fplbase::Mesh::min_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum position of an AABB about the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the minimum position of the mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="af9e5bcb4f1b14a51fab19dfa924b868a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t fplbase::Mesh::num_bones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bones in the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bones. </dd></dl>

</div>
</div>
<a class="anchor" id="aa440c5b19f40c3719c73e7c1e86b7bdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t fplbase::Mesh::num_shader_bones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bones used by the shader. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bones used by the shader. </dd></dl>

</div>
</div>
<a class="anchor" id="a552626bc96b1686f4f5ed44718995f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::Render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_material</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render the mesh. </p>
<p>Call to have the mesh render itself. Uniforms must have been set before calling this. For instanced rendering, pass in a value &gt;1 (needs OpenGL ES 3.0 to work).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>The renderer object to be used. </td></tr>
    <tr><td class="paramname">ignore_material</td><td>Whether to ignore the meshes defined material. </td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to be rendered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af892718f24e323cd1fdf6f52e945d0d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::RenderAAQuadAlongX </td>
          <td>(</td>
          <td class="paramtype">const mathfu::vec3 &amp;&#160;</td>
          <td class="paramname"><em>bottom_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec3 &amp;&#160;</td>
          <td class="paramname"><em>top_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec2 &amp;&#160;</td>
          <td class="paramname"><em>tex_bottom_left</em> = <code>mathfu::vec2(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec2 &amp;&#160;</td>
          <td class="paramname"><em>tex_top_right</em> = <code>mathfu::vec2(1,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for rendering a Quad. </p>
<p>bottom_left and top_right must have their X coordinate be different, but either Y or Z can be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom_left</td><td>The bottom left coordinate of the Quad. </td></tr>
    <tr><td class="paramname">top_right</td><td>The bottom left coordinate of the Quad. </td></tr>
    <tr><td class="paramname">tex_bottom_left</td><td>The texture coordinates at the bottom left. </td></tr>
    <tr><td class="paramname">tex_top_right</td><td>The texture coordinates at the top right. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a941da21a44789d08f972122633c356af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::RenderAAQuadAlongXNinePatch </td>
          <td>(</td>
          <td class="paramtype">const mathfu::vec3 &amp;&#160;</td>
          <td class="paramname"><em>bottom_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec3 &amp;&#160;</td>
          <td class="paramname"><em>top_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec2i &amp;&#160;</td>
          <td class="paramname"><em>texture_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec4 &amp;&#160;</td>
          <td class="paramname"><em>patch_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for rendering a Quad with nine patch settings. </p>
<p>In the patch_info, the user can define nine patch settings as vec4(x0, y0, x1, y1) where (x0,y0): top-left corner of stretchable area in UV coordinate. (x1,y1): bottom-right corner of stretchable area in UV coordinate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom_left</td><td>The bottom left coordinate of the Quad. </td></tr>
    <tr><td class="paramname">top_right</td><td>The top right coordinate of the Quad. </td></tr>
    <tr><td class="paramname">texture_size</td><td>The size of the texture used by the patches. </td></tr>
    <tr><td class="paramname">patch_info</td><td>Defines how the patches are set up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f7bfae0ab41c198e1d9843010e049bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::RenderArray </td>
          <td>(</td>
          <td class="paramtype">Primitive&#160;</td>
          <td class="paramname"><em>primitive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Attribute *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders the given vertex and index data directly. </p>
<p>Renders primitives using vertex and index data directly in local memory. This is a convenient alternative to creating a <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> instance for small amounts of data, or dynamic data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitive</td><td>The type of primitive to render the data as. </td></tr>
    <tr><td class="paramname">index_count</td><td>The total number of indices. </td></tr>
    <tr><td class="paramname">format</td><td>The vertex buffer format, following the same rules as described in <a class="el" href="classfplbase_1_1_mesh.html#a99db7c679fa5afbdc4e17cdeb30eaa7e" title="Define the vertex buffer format. ">set_format()</a>. </td></tr>
    <tr><td class="paramname">vertex_size</td><td>The size of an individual vertex. </td></tr>
    <tr><td class="paramname">vertices</td><td>The array of vertices. </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices into the vertex array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99db7c679fa5afbdc4e17cdeb30eaa7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::set_format </td>
          <td>(</td>
          <td class="paramtype">const Attribute *&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the vertex buffer format. </p>
<p><code>format</code> must have length &lt;= kMaxAttributes, including <code>kEND</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Array of attributes to set the format to, delimitted with <code>kEND</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1f787785d01d9dd731624d3bcef6362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::SetBones </td>
          <td>(</td>
          <td class="paramtype">const mathfu::AffineTransform *&#160;</td>
          <td class="paramname"><em>bone_transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bone_parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>bone_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>shader_bone_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_shader_bones</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bones used by an animated mesh. </p>
<p>If mesh is animated set the transform from a bone's parent space into the bone's local space. Optionally record the bone names, too, for debugging. The shader only accesses a bone if at least one vertex is weighted to it. So, we don't have to pass every bone transform up to the shader. Instead, we compact the bone transforms by passing only those in shader_bone_indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bone_transforms</td><td>Array of bones to be used. </td></tr>
    <tr><td class="paramname">bone_parents</td><td>Array that contains, for each bone, the index of its parent. </td></tr>
    <tr><td class="paramname">bone_names</td><td>Array containing the names of the bones. </td></tr>
    <tr><td class="paramname">num_bones</td><td>The number of bones in the given array. </td></tr>
    <tr><td class="paramname">shader_bone_indices</td><td>The indices of bones used by the shader. </td></tr>
    <tr><td class="paramname">num_shader_bones</td><td>The number of bones in the shader bones array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5aeaa120faafcf24302e1399f50eb4ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* fplbase::Mesh::shader_bone_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The indices of bones used by the shader. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an array of indices of bones used by the shader. </dd></dl>

</div>
</div>
<a class="anchor" id="af3db409ea671ecd2fdae87fc47cdb5fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t fplbase::Mesh::VertexSize </td>
          <td>(</td>
          <td class="paramtype">const Attribute *&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Attribute&#160;</td>
          <td class="paramname"><em>end</em> = <code>kEND</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the byte size for a vertex from given attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>The array of attributes describing the vertex. </td></tr>
    <tr><td class="paramname">end</td><td>The attribute to treat as the end of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte size based on the given attributes. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mesh_8h_source.html">mesh.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-49880327-7', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>
