<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>FPLBase: fplbase::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400italic,500,500italic,700,700italic|Roboto+Mono:400,700" rel="stylesheet">
<link href="style.css" rel="stylesheet" type="text/css"/>
<script>
  /**
   * Check if the browser rendering this page is being run on an Android device.
   * It checks if the string 'android' is found in the browser's `userAgent`.
   * @return {boolean} This returns `true` if the browser's `userAgent` contains
   * the string 'android' (indicating that the browser is on an Android device).
   * Otherwise, it returns `false`.
   */
  function isAndroidDevice() {
    if (navigator && navigator.userAgent) {
      return navigator.userAgent.toLowerCase().indexOf('android') != -1;
    } else {
      return false;
    }
  }
  /**
   * Check if an HTML `class` attribute is in the browser-specific format.
   * @param {string} An HTML `class` attribute in the format 'browser-{device}'.
   * @return {boolean} Returns `true` if `browserClass` was in the valid format,
   * prefixed with 'browser-'. Otherwise, it returns false.
   */
  function isBrowserSpecificClassName(browserClass) {
    if (browserClass && browserClass.substring(0, 8) == 'browser-' &&
        browserClass.length > 8) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Get all the HTML Elements with browser-specific `class` attributes.
   * @return {array} Returns an array of all the HTML Elements with a `class`
   * attribute that is prefixed with `browser-`.
   */
  function getAllBrowserSpecificElements() {
    if (document) {
      var htmlElements = document.getElementsByTagName("*");
      var browserSpecificElements = [];
      for (var i = 0; i < htmlElements.length; i++) {
        if (isBrowserSpecificClassName(htmlElements[i].className)) {
          browserSpecificElements.push(htmlElements[i]);
        }
      }
      return browserSpecificElements;
    } else {
      return null;
    }
  }
  /**
   * Given a browser-specific HTML `class` attribute, extract the device name.
   * @param {string} browserClass The string name of an HTML `class` attribute,
   * in the format `browser-{device}`.
   * @return {string} Returns a string containing only the device portion of
   * the class name. If the input was invalid, then it returns `null`.
   */
  function extractDeviceFromBrowserClass(browserClass) {
    if (isBrowserSpecificClassName(browserClass)) {
      return browserClass.substring(8);
    }
    else {
      return null;
    }
  }
  /**
   * Hide device specific elements that do not apply to the current device.
   */
  function handleDeviceSpecificLoading() {
    var browserSpecificElements = getAllBrowserSpecificElements();
    for (var i = 0; i < browserSpecificElements.length; i++) {
      var device = extractDeviceFromBrowserClass(browserSpecificElements[i].className);
      if (device && !isAndroidDevice() && device == 'android') {
        browserSpecificElements[i].innerHTML = '';
      } else if(device && isAndroidDevice() && device == 'desktop') {
        browserSpecificElements[i].innerHTML = '';
      }
    }
  }
  $(document).ready(handleDeviceSpecificLoading);
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="commonprojectlogo">
    <img alt="Logo" src="fpl_logo_small.png"/>
  </td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">FPLBase
   </div>
   <div style="font-size:12px;">
	 An open source project by
     <a href="https://developers.google.com/games/#Tools">FPL</a>.
  </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="usergroup0.html"><span>Programmer's&#160;Guide</span></a></li>
      <li class="current"><a href="fplbase_api_reference.html"><span>API&#160;reference</span></a></li>
      <li><a href="contributing.html"><span>Contributing</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classfplbase_1_1_mesh.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfplbase_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fplbase::Mesh Class Reference<div class="ingroups"><a class="el" href="group__fplbase__mesh.html">Mesh</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstraction for a set of indices, used for rendering.  
 <a href="classfplbase_1_1_mesh.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mesh_8h_source.html">mesh.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fplbase::Mesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classfplbase_1_1_mesh.png" usemap="#fplbase::Mesh_map" alt=""/>
  <map id="fplbase::Mesh_map" name="fplbase::Mesh_map">
<area href="classfplbase_1_1_async_asset.html" alt="fplbase::AsyncAsset" shape="rect" coords="0,56,126,80"/>
<area href="classfplbase_1_1_asset.html" title="Base class of all assets that may be managed by Assetmanager. " alt="fplbase::Asset" shape="rect" coords="0,0,126,24"/>
</map>
 </div></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstraction for a set of indices, used for rendering. </p>
<p>A mesh instance contains a VBO and one or more IBO's. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfplbase_1_1_mesh_1_1_interleaved_vertex_data.html">InterleavedVertexData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holder for data that can be turned into a mesh.  <a href="structfplbase_1_1_mesh_1_1_interleaved_vertex_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abd19aac0cef94b0fb47035805e3c02d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Primitive</b> { <br/>
&#160;&#160;<b>kTriangles</b>, 
<b>kTriangleStrip</b>, 
<b>kTriangleFan</b>, 
<b>kLines</b>, 
<br/>
&#160;&#160;<b>kPoints</b>
<br/>
 }</td></tr>
<tr class="separator:abd19aac0cef94b0fb47035805e3c02d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a1a13a9d08c50084ddd354160bd84b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>kAttributePosition</b>, 
<b>kAttributeNormal</b>, 
<b>kAttributeTangent</b>, 
<b>kAttributeTexCoord</b>, 
<br/>
&#160;&#160;<b>kAttributeTexCoordAlt</b>, 
<b>kAttributeColor</b>, 
<b>kAttributeBoneIndices</b>, 
<b>kAttributeBoneWeights</b>
<br/>
 }</td></tr>
<tr class="separator:a91a1a13a9d08c50084ddd354160bd84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1492e9684b8c40aa6033ff01af038f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f1492e9684b8c40aa6033ff01af038f"></a>
typedef std::function<br class="typebreak"/>
&lt; <a class="el" href="classfplbase_1_1_material.html">Material</a> *(const char <br class="typebreak"/>
*<a class="el" href="classfplbase_1_1_async_asset.html#a7eab931d69c4dd9811d2f445a3209de2">filename</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MaterialLoaderFn</b></td></tr>
<tr class="separator:a0f1492e9684b8c40aa6033ff01af038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classfplbase_1_1_async_asset"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classfplbase_1_1_async_asset')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classfplbase_1_1_async_asset.html">fplbase::AsyncAsset</a></td></tr>
<tr class="memitem:a35322af2d9aab42ad36e45a7590850c7 inherit pub_types_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35322af2d9aab42ad36e45a7590850c7"></a>
typedef std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a35322af2d9aab42ad36e45a7590850c7">AssetFinalizedCallback</a></td></tr>
<tr class="memdesc:a35322af2d9aab42ad36e45a7590850c7 inherit pub_types_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to an asset loaded callback function. <br/></td></tr>
<tr class="separator:a35322af2d9aab42ad36e45a7590850c7 inherit pub_types_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74af5c6157c6c337570c6cce45ba6c9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a74af5c6157c6c337570c6cce45ba6c9f">Mesh</a> (const char *<a class="el" href="classfplbase_1_1_async_asset.html#a7eab931d69c4dd9811d2f445a3209de2">filename</a>=nullptr, MaterialLoaderFn material_loader_fn=nullptr, Primitive primitive=kTriangles)</td></tr>
<tr class="memdesc:a74af5c6157c6c337570c6cce45ba6c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> from a file asynchronously.  <a href="#a74af5c6157c6c337570c6cce45ba6c9f">More...</a><br/></td></tr>
<tr class="separator:a74af5c6157c6c337570c6cce45ba6c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cfa0a33f81bdf8a57bdbfa599a5384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60cfa0a33f81bdf8a57bdbfa599a5384"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a60cfa0a33f81bdf8a57bdbfa599a5384">Mesh</a> (const void *vertex_data, size_t count, size_t vertex_size, const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *format, mathfu::vec3 *<a class="el" href="classfplbase_1_1_mesh.html#a1897261b1050950e6d650c19cd28332d">max_position</a>=nullptr, mathfu::vec3 *<a class="el" href="classfplbase_1_1_mesh.html#add6031658ca8b8eb900bd5c63a215d29">min_position</a>=nullptr, Primitive primitive=kTriangles)</td></tr>
<tr class="memdesc:a60cfa0a33f81bdf8a57bdbfa599a5384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> by creating one VBO, and no IBO's. <br/></td></tr>
<tr class="separator:a60cfa0a33f81bdf8a57bdbfa599a5384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc43c015a3fca34919c9f1eeefe134a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bc43c015a3fca34919c9f1eeefe134a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a0bc43c015a3fca34919c9f1eeefe134a">LoadFromMemory</a> (const void *vertex_data, size_t count, size_t vertex_size, const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *format, mathfu::vec3 *<a class="el" href="classfplbase_1_1_mesh.html#a1897261b1050950e6d650c19cd28332d">max_position</a>=nullptr, mathfu::vec3 *<a class="el" href="classfplbase_1_1_mesh.html#add6031658ca8b8eb900bd5c63a215d29">min_position</a>=nullptr)</td></tr>
<tr class="memdesc:a0bc43c015a3fca34919c9f1eeefe134a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> by creating one VBO, and no IBO's. <br/></td></tr>
<tr class="separator:a0bc43c015a3fca34919c9f1eeefe134a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3d6c89f27e221462da976a2f544e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55a3d6c89f27e221462da976a2f544e5"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a55a3d6c89f27e221462da976a2f544e5">Load</a> ()</td></tr>
<tr class="memdesc:a55a3d6c89f27e221462da976a2f544e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads and unpacks the <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> from 'filename_' and 'data_'. <br/></td></tr>
<tr class="separator:a55a3d6c89f27e221462da976a2f544e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05ff07df30c5b269b096264b2c53698"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad05ff07df30c5b269b096264b2c53698"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#ad05ff07df30c5b269b096264b2c53698">Finalize</a> ()</td></tr>
<tr class="memdesc:ad05ff07df30c5b269b096264b2c53698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mesh from 'data_'. <br/></td></tr>
<tr class="separator:ad05ff07df30c5b269b096264b2c53698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecc29c5b2d4847b35990875ae7f78bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ecc29c5b2d4847b35990875ae7f78bd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a0ecc29c5b2d4847b35990875ae7f78bd">IsValid</a> ()</td></tr>
<tr class="memdesc:a0ecc29c5b2d4847b35990875ae7f78bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this object loaded and finalized correctly. Call after Finalize has been called (by <a class="el" href="classfplbase_1_1_asset_manager.html#ae29c7b975117946ee6c75dbb970909d6" title="Check for the status of async loading resources. ">AssetManager::TryFinalize</a>). <br/></td></tr>
<tr class="separator:a0ecc29c5b2d4847b35990875ae7f78bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83df5228d62ba8ddcf4626f17df538ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a83df5228d62ba8ddcf4626f17df538ec">AddIndices</a> (const void *indices, int count, <a class="el" href="classfplbase_1_1_material.html">Material</a> *mat, bool is_32_bit=false)</td></tr>
<tr class="memdesc:a83df5228d62ba8ddcf4626f17df538ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an index buffer object to be part of this mesh.  <a href="#a83df5228d62ba8ddcf4626f17df538ec">More...</a><br/></td></tr>
<tr class="separator:a83df5228d62ba8ddcf4626f17df538ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f787785d01d9dd731624d3bcef6362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#ad1f787785d01d9dd731624d3bcef6362">SetBones</a> (const mathfu::AffineTransform *bone_transforms, const uint8_t *<a class="el" href="classfplbase_1_1_mesh.html#a8ba887b02a8a87eb6060a613eb5d9c05">bone_parents</a>, const char **<a class="el" href="classfplbase_1_1_mesh.html#af85ef1712706f970e086b5f8a5c25841">bone_names</a>, size_t <a class="el" href="classfplbase_1_1_mesh.html#af9e5bcb4f1b14a51fab19dfa924b868a">num_bones</a>, const uint8_t *<a class="el" href="classfplbase_1_1_mesh.html#a5aeaa120faafcf24302e1399f50eb4ca">shader_bone_indices</a>, size_t <a class="el" href="classfplbase_1_1_mesh.html#aa440c5b19f40c3719c73e7c1e86b7bdd">num_shader_bones</a>)</td></tr>
<tr class="memdesc:ad1f787785d01d9dd731624d3bcef6362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bones used by an animated mesh.  <a href="#ad1f787785d01d9dd731624d3bcef6362">More...</a><br/></td></tr>
<tr class="separator:ad1f787785d01d9dd731624d3bcef6362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534ad4d50aec1afdbf649d7831d5ddd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a534ad4d50aec1afdbf649d7831d5ddd1">GatherShaderTransforms</a> (const mathfu::AffineTransform *bone_transforms, mathfu::AffineTransform *shader_transforms) const </td></tr>
<tr class="memdesc:a534ad4d50aec1afdbf649d7831d5ddd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert bone transforms for consumption by a skinning shader.  <a href="#a534ad4d50aec1afdbf649d7831d5ddd1">More...</a><br/></td></tr>
<tr class="separator:a534ad4d50aec1afdbf649d7831d5ddd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552626bc96b1686f4f5ed44718995f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a552626bc96b1686f4f5ed44718995f4f">Render</a> (<a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;renderer, bool ignore_material=false, size_t instances=1)</td></tr>
<tr class="memdesc:a552626bc96b1686f4f5ed44718995f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render the mesh.  <a href="#a552626bc96b1686f4f5ed44718995f4f">More...</a><br/></td></tr>
<tr class="separator:a552626bc96b1686f4f5ed44718995f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679461e3577a5f1a33b924323c011e06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a679461e3577a5f1a33b924323c011e06">RenderStereo</a> (<a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;renderer, const <a class="el" href="classfplbase_1_1_shader.html">Shader</a> *shader, const <a class="el" href="namespacefplbase.html#ab4c9bd1f04da97001d01f0dc1f9689ce">Viewport</a> *viewport, const mathfu::mat4 *mvp, const mathfu::vec3 *camera_position, bool ignore_material=false, size_t instances=1)</td></tr>
<tr class="memdesc:a679461e3577a5f1a33b924323c011e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Render the mesh, itself, into stereoscopic viewports.  <a href="#a679461e3577a5f1a33b924323c011e06">More...</a><br/></td></tr>
<tr class="separator:a679461e3577a5f1a33b924323c011e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d9c1b83bbd142547c749775c2f6287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfplbase_1_1_material.html">Material</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#ac7d9c1b83bbd142547c749775c2f6287">GetMaterial</a> (int i)</td></tr>
<tr class="memdesc:ac7d9c1b83bbd142547c749775c2f6287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the material associated with the IBO at the given index.  <a href="#ac7d9c1b83bbd142547c749775c2f6287">More...</a><br/></td></tr>
<tr class="separator:ac7d9c1b83bbd142547c749775c2f6287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99db7c679fa5afbdc4e17cdeb30eaa7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a99db7c679fa5afbdc4e17cdeb30eaa7e">set_format</a> (const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *format)</td></tr>
<tr class="memdesc:a99db7c679fa5afbdc4e17cdeb30eaa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the vertex buffer format.  <a href="#a99db7c679fa5afbdc4e17cdeb30eaa7e">More...</a><br/></td></tr>
<tr class="separator:a99db7c679fa5afbdc4e17cdeb30eaa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6031658ca8b8eb900bd5c63a215d29"><td class="memItemLeft" align="right" valign="top">const mathfu::vec3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#add6031658ca8b8eb900bd5c63a215d29">min_position</a> () const </td></tr>
<tr class="memdesc:add6031658ca8b8eb900bd5c63a215d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum position of an AABB about the mesh.  <a href="#add6031658ca8b8eb900bd5c63a215d29">More...</a><br/></td></tr>
<tr class="separator:add6031658ca8b8eb900bd5c63a215d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1897261b1050950e6d650c19cd28332d"><td class="memItemLeft" align="right" valign="top">const mathfu::vec3 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a1897261b1050950e6d650c19cd28332d">max_position</a> () const </td></tr>
<tr class="memdesc:a1897261b1050950e6d650c19cd28332d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum position of an AABB about the mesh.  <a href="#a1897261b1050950e6d650c19cd28332d">More...</a><br/></td></tr>
<tr class="separator:a1897261b1050950e6d650c19cd28332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba887b02a8a87eb6060a613eb5d9c05"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a8ba887b02a8a87eb6060a613eb5d9c05">bone_parents</a> () const </td></tr>
<tr class="memdesc:a8ba887b02a8a87eb6060a613eb5d9c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The defines parents of each bone.  <a href="#a8ba887b02a8a87eb6060a613eb5d9c05">More...</a><br/></td></tr>
<tr class="separator:a8ba887b02a8a87eb6060a613eb5d9c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85ef1712706f970e086b5f8a5c25841"><td class="memItemLeft" align="right" valign="top">const std::string *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#af85ef1712706f970e086b5f8a5c25841">bone_names</a> () const </td></tr>
<tr class="memdesc:af85ef1712706f970e086b5f8a5c25841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of names for each bone.  <a href="#af85ef1712706f970e086b5f8a5c25841">More...</a><br/></td></tr>
<tr class="separator:af85ef1712706f970e086b5f8a5c25841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b50fd1237871bc8d793827818212860"><td class="memItemLeft" align="right" valign="top">const mathfu::AffineTransform *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a4b50fd1237871bc8d793827818212860">default_bone_transform_inverses</a> () const </td></tr>
<tr class="memdesc:a4b50fd1237871bc8d793827818212860"><td class="mdescLeft">&#160;</td><td class="mdescRight">The array of default bone transform inverses.  <a href="#a4b50fd1237871bc8d793827818212860">More...</a><br/></td></tr>
<tr class="separator:a4b50fd1237871bc8d793827818212860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e5bcb4f1b14a51fab19dfa924b868a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#af9e5bcb4f1b14a51fab19dfa924b868a">num_bones</a> () const </td></tr>
<tr class="memdesc:af9e5bcb4f1b14a51fab19dfa924b868a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bones in the mesh.  <a href="#af9e5bcb4f1b14a51fab19dfa924b868a">More...</a><br/></td></tr>
<tr class="separator:af9e5bcb4f1b14a51fab19dfa924b868a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aeaa120faafcf24302e1399f50eb4ca"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a5aeaa120faafcf24302e1399f50eb4ca">shader_bone_indices</a> () const </td></tr>
<tr class="memdesc:a5aeaa120faafcf24302e1399f50eb4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indices of bones used by the shader.  <a href="#a5aeaa120faafcf24302e1399f50eb4ca">More...</a><br/></td></tr>
<tr class="separator:a5aeaa120faafcf24302e1399f50eb4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa440c5b19f40c3719c73e7c1e86b7bdd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#aa440c5b19f40c3719c73e7c1e86b7bdd">num_shader_bones</a> () const </td></tr>
<tr class="memdesc:aa440c5b19f40c3719c73e7c1e86b7bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bones used by the shader.  <a href="#aa440c5b19f40c3719c73e7c1e86b7bdd">More...</a><br/></td></tr>
<tr class="separator:aa440c5b19f40c3719c73e7c1e86b7bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b796e760de088d73563b0afed7c6d82"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a1b796e760de088d73563b0afed7c6d82">num_vertices</a> () const </td></tr>
<tr class="memdesc:a1b796e760de088d73563b0afed7c6d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of vertices in the VBO.  <a href="#a1b796e760de088d73563b0afed7c6d82">More...</a><br/></td></tr>
<tr class="separator:a1b796e760de088d73563b0afed7c6d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3ddf8bbd22f78435b33f738ad9577d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#afb3ddf8bbd22f78435b33f738ad9577d">CalculateTotalNumberOfIndices</a> () const </td></tr>
<tr class="memdesc:afb3ddf8bbd22f78435b33f738ad9577d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of indices in all IBOs.  <a href="#afb3ddf8bbd22f78435b33f738ad9577d">More...</a><br/></td></tr>
<tr class="separator:afb3ddf8bbd22f78435b33f738ad9577d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da7160fa20b97b24481765c6a14e165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9da7160fa20b97b24481765c6a14e165"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a9da7160fa20b97b24481765c6a14e165">ParseInterleavedVertexData</a> (const void *meshdef_buffer, <a class="el" href="structfplbase_1_1_mesh_1_1_interleaved_vertex_data.html">InterleavedVertexData</a> *ivd)</td></tr>
<tr class="memdesc:a9da7160fa20b97b24481765c6a14e165"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Load vertex data from a FlatBuffer into CPU memory first. <br/></td></tr>
<tr class="separator:a9da7160fa20b97b24481765c6a14e165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classfplbase_1_1_async_asset"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classfplbase_1_1_async_asset')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classfplbase_1_1_async_asset.html">fplbase::AsyncAsset</a></td></tr>
<tr class="memitem:a67d8e1558310a6a0b426e754063e83b4 inherit pub_methods_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67d8e1558310a6a0b426e754063e83b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a67d8e1558310a6a0b426e754063e83b4">AsyncAsset</a> ()</td></tr>
<tr class="memdesc:a67d8e1558310a6a0b426e754063e83b4 inherit pub_methods_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for an empty <a class="el" href="classfplbase_1_1_async_asset.html">AsyncAsset</a>. <br/></td></tr>
<tr class="separator:a67d8e1558310a6a0b426e754063e83b4 inherit pub_methods_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0dcb4fa2af6cb47bcc59d8cf0a4e6a inherit pub_methods_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a6f0dcb4fa2af6cb47bcc59d8cf0a4e6a">AsyncAsset</a> (const char *<a class="el" href="classfplbase_1_1_async_asset.html#a7eab931d69c4dd9811d2f445a3209de2">filename</a>)</td></tr>
<tr class="memdesc:a6f0dcb4fa2af6cb47bcc59d8cf0a4e6a inherit pub_methods_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <a class="el" href="classfplbase_1_1_async_asset.html">AsyncAsset</a> with a given file name.  <a href="#a6f0dcb4fa2af6cb47bcc59d8cf0a4e6a">More...</a><br/></td></tr>
<tr class="separator:a6f0dcb4fa2af6cb47bcc59d8cf0a4e6a inherit pub_methods_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7afaa3797fc5baa07246104047a2fa inherit pub_methods_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d7afaa3797fc5baa07246104047a2fa"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a1d7afaa3797fc5baa07246104047a2fa">~AsyncAsset</a> ()</td></tr>
<tr class="memdesc:a1d7afaa3797fc5baa07246104047a2fa inherit pub_methods_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classfplbase_1_1_async_asset.html">AsyncAsset</a> destructor. <br/></td></tr>
<tr class="separator:a1d7afaa3797fc5baa07246104047a2fa inherit pub_methods_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ace8aab064a202be8cf16529c36e2fc inherit pub_methods_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a0ace8aab064a202be8cf16529c36e2fc">LoadNow</a> ()</td></tr>
<tr class="memdesc:a0ace8aab064a202be8cf16529c36e2fc inherit pub_methods_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a synchronous load by calling Load &amp; Finalize.  <a href="#a0ace8aab064a202be8cf16529c36e2fc">More...</a><br/></td></tr>
<tr class="separator:a0ace8aab064a202be8cf16529c36e2fc inherit pub_methods_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac5c1b286def45d4777a02a8df6d18c inherit pub_methods_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#abac5c1b286def45d4777a02a8df6d18c">set_filename</a> (const std::string &amp;<a class="el" href="classfplbase_1_1_async_asset.html#a7eab931d69c4dd9811d2f445a3209de2">filename</a>)</td></tr>
<tr class="memdesc:abac5c1b286def45d4777a02a8df6d18c inherit pub_methods_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the filename that should be loaded.  <a href="#abac5c1b286def45d4777a02a8df6d18c">More...</a><br/></td></tr>
<tr class="separator:abac5c1b286def45d4777a02a8df6d18c inherit pub_methods_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eab931d69c4dd9811d2f445a3209de2 inherit pub_methods_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a7eab931d69c4dd9811d2f445a3209de2">filename</a> () const </td></tr>
<tr class="memdesc:a7eab931d69c4dd9811d2f445a3209de2 inherit pub_methods_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the file associated with the resource.  <a href="#a7eab931d69c4dd9811d2f445a3209de2">More...</a><br/></td></tr>
<tr class="separator:a7eab931d69c4dd9811d2f445a3209de2 inherit pub_methods_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8929bf9946ab10e3746b7fd32ac70cac inherit pub_methods_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a8929bf9946ab10e3746b7fd32ac70cac">AddFinalizeCallback</a> (<a class="el" href="classfplbase_1_1_async_asset.html#a35322af2d9aab42ad36e45a7590850c7">AssetFinalizedCallback</a> callback)</td></tr>
<tr class="memdesc:a8929bf9946ab10e3746b7fd32ac70cac inherit pub_methods_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to be called when the asset is finalized.  <a href="#a8929bf9946ab10e3746b7fd32ac70cac">More...</a><br/></td></tr>
<tr class="separator:a8929bf9946ab10e3746b7fd32ac70cac inherit pub_methods_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classfplbase_1_1_asset"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classfplbase_1_1_asset')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classfplbase_1_1_asset.html">fplbase::Asset</a></td></tr>
<tr class="memitem:a00d0bd9760a5bd0031452da00308ee19 inherit pub_methods_classfplbase_1_1_asset"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00d0bd9760a5bd0031452da00308ee19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_asset.html#a00d0bd9760a5bd0031452da00308ee19">IncreaseRefCount</a> ()</td></tr>
<tr class="memdesc:a00d0bd9760a5bd0031452da00308ee19 inherit pub_methods_classfplbase_1_1_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate there is an additional owner of this asset. By default, when you call any of the UnLoad*() functions in the <a class="el" href="classfplbase_1_1_asset_manager.html" title="Central place to own game assets loaded from disk. ">AssetManager</a>, that will directly delete the asset since they all start out with a single reference count. Call this function to indicate multiple owners will call Unload*() independently, and only have the asset deleted by the last one. <br/></td></tr>
<tr class="separator:a00d0bd9760a5bd0031452da00308ee19 inherit pub_methods_classfplbase_1_1_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7f7bfae0ab41c198e1d9843010e049bf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a7f7bfae0ab41c198e1d9843010e049bf">RenderArray</a> (Primitive primitive, int index_count, const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *format, int vertex_size, const void *vertices, const unsigned short *indices)</td></tr>
<tr class="memdesc:a7f7bfae0ab41c198e1d9843010e049bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the given vertex and index data directly.  <a href="#a7f7bfae0ab41c198e1d9843010e049bf">More...</a><br/></td></tr>
<tr class="separator:a7f7bfae0ab41c198e1d9843010e049bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dbef0bc37c522b63c577a4a616f7dd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#aa6dbef0bc37c522b63c577a4a616f7dd">RenderArray</a> (Primitive primitive, int vertex_count, const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *format, int vertex_size, const void *vertices)</td></tr>
<tr class="memdesc:aa6dbef0bc37c522b63c577a4a616f7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders the given vertex data directly.  <a href="#aa6dbef0bc37c522b63c577a4a616f7dd">More...</a><br/></td></tr>
<tr class="separator:aa6dbef0bc37c522b63c577a4a616f7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af892718f24e323cd1fdf6f52e945d0d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#af892718f24e323cd1fdf6f52e945d0d2">RenderAAQuadAlongX</a> (const mathfu::vec3 &amp;bottom_left, const mathfu::vec3 &amp;top_right, const mathfu::vec2 &amp;tex_bottom_left=mathfu::vec2(0, 0), const mathfu::vec2 &amp;tex_top_right=mathfu::vec2(1, 1))</td></tr>
<tr class="memdesc:af892718f24e323cd1fdf6f52e945d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for rendering a Quad.  <a href="#af892718f24e323cd1fdf6f52e945d0d2">More...</a><br/></td></tr>
<tr class="separator:af892718f24e323cd1fdf6f52e945d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941da21a44789d08f972122633c356af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a941da21a44789d08f972122633c356af">RenderAAQuadAlongXNinePatch</a> (const mathfu::vec3 &amp;bottom_left, const mathfu::vec3 &amp;top_right, const mathfu::vec2i &amp;texture_size, const mathfu::vec4 &amp;patch_info)</td></tr>
<tr class="memdesc:a941da21a44789d08f972122633c356af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for rendering a Quad with nine patch settings.  <a href="#a941da21a44789d08f972122633c356af">More...</a><br/></td></tr>
<tr class="separator:a941da21a44789d08f972122633c356af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a432d7b64495f28648555104dd74bf0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a432d7b64495f28648555104dd74bf0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#a9a432d7b64495f28648555104dd74bf0">ComputeNormalsTangents</a> (T *vertices, const unsigned short *indices, int numverts, int numindices)</td></tr>
<tr class="memdesc:a9a432d7b64495f28648555104dd74bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normals and tangents given position and texcoords.  <a href="#a9a432d7b64495f28648555104dd74bf0">More...</a><br/></td></tr>
<tr class="separator:a9a432d7b64495f28648555104dd74bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3db409ea671ecd2fdae87fc47cdb5fb"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_mesh.html#af3db409ea671ecd2fdae87fc47cdb5fb">VertexSize</a> (const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *attributes, <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> end=<a class="el" href="group__fplbase__mesh.html#gga32e078df53a6a42cb90430d93d4df3f5ad6fe577dc2b397bb3a6922341656a5e9">kEND</a>)</td></tr>
<tr class="memdesc:af3db409ea671ecd2fdae87fc47cdb5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the byte size for a vertex from given attributes.  <a href="#af3db409ea671ecd2fdae87fc47cdb5fb">More...</a><br/></td></tr>
<tr class="separator:af3db409ea671ecd2fdae87fc47cdb5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classfplbase_1_1_async_asset"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classfplbase_1_1_async_asset')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classfplbase_1_1_async_asset.html">fplbase::AsyncAsset</a></td></tr>
<tr class="memitem:a3ef25c954ae387e1ade0b93aa1e0de0b inherit pro_methods_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a3ef25c954ae387e1ade0b93aa1e0de0b">CallFinalizeCallback</a> ()</td></tr>
<tr class="memdesc:a3ef25c954ae387e1ade0b93aa1e0de0b inherit pro_methods_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls app callbacks when an asset is ready to be used.  <a href="#a3ef25c954ae387e1ade0b93aa1e0de0b">More...</a><br/></td></tr>
<tr class="separator:a3ef25c954ae387e1ade0b93aa1e0de0b inherit pro_methods_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classfplbase_1_1_async_asset"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classfplbase_1_1_async_asset')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classfplbase_1_1_async_asset.html">fplbase::AsyncAsset</a></td></tr>
<tr class="memitem:a6df3bcb8e3b74ee50b92edf0f151ec19 inherit pro_attribs_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df3bcb8e3b74ee50b92edf0f151ec19"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a6df3bcb8e3b74ee50b92edf0f151ec19">filename_</a></td></tr>
<tr class="memdesc:a6df3bcb8e3b74ee50b92edf0f151ec19 inherit pro_attribs_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resource file name. <br/></td></tr>
<tr class="separator:a6df3bcb8e3b74ee50b92edf0f151ec19 inherit pro_attribs_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68dde2e8c0e5bb0007146aac0f28fc inherit pro_attribs_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a68dde2e8c0e5bb0007146aac0f28fc"></a>
const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfplbase_1_1_async_asset.html#a1a68dde2e8c0e5bb0007146aac0f28fc">data_</a></td></tr>
<tr class="memdesc:a1a68dde2e8c0e5bb0007146aac0f28fc inherit pro_attribs_classfplbase_1_1_async_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">The resource data. <br/></td></tr>
<tr class="separator:a1a68dde2e8c0e5bb0007146aac0f28fc inherit pro_attribs_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa440aabc91e56a56edbdaecc541396f5 inherit pro_attribs_classfplbase_1_1_async_asset"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa440aabc91e56a56edbdaecc541396f5"></a>
std::vector<br class="typebreak"/>
&lt; <a class="el" href="classfplbase_1_1_async_asset.html#a35322af2d9aab42ad36e45a7590850c7">AssetFinalizedCallback</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>finalize_callbacks_</b></td></tr>
<tr class="separator:aa440aabc91e56a56edbdaecc541396f5 inherit pro_attribs_classfplbase_1_1_async_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a74af5c6157c6c337570c6cce45ba6c9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fplbase::Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MaterialLoaderFn&#160;</td>
          <td class="paramname"><em>material_loader_fn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Primitive&#160;</td>
          <td class="paramname"><em>primitive</em> = <code>kTriangles</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> from a file asynchronously. </p>
<p>Asynchronously create mesh from a file if filename is valid. Otherwise, if filename is null, need to call LoadFromMemory to init manually. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a83df5228d62ba8ddcf4626f17df538ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::AddIndices </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfplbase_1_1_material.html">Material</a> *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_32_bit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an index buffer object to be part of this mesh. </p>
<p>Create one IBO to be part of this mesh. May be called more than once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to be included in the IBO. </td></tr>
    <tr><td class="paramname">count</td><td>The number of indices. </td></tr>
    <tr><td class="paramname">mat</td><td>The material associated with the IBO. </td></tr>
    <tr><td class="paramname">is_32_bit</td><td>Specifies that the indices are 32bit. Default 16bit. </td></tr>
    <tr><td class="paramname">primitive</td><td>How the triangles are assembled from the indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af85ef1712706f970e086b5f8a5c25841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string* fplbase::Mesh::bone_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of names for each bone. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the array of names for each bone, of length <a class="el" href="classfplbase_1_1_mesh.html#af9e5bcb4f1b14a51fab19dfa924b868a" title="The number of bones in the mesh. ">num_bones()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ba887b02a8a87eb6060a613eb5d9c05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* fplbase::Mesh::bone_parents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The defines parents of each bone. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an array of indices of each bone's parent. </dd></dl>

</div>
</div>
<a class="anchor" id="afb3ddf8bbd22f78435b33f738ad9577d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fplbase::Mesh::CalculateTotalNumberOfIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of indices in all IBOs. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total number of indices across all IBOs. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a432d7b64495f28648555104dd74bf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::ComputeNormalsTangents </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numverts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numindices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute normals and tangents given position and texcoords. </p>
<p>The template type should be a struct with at least the following fields: mathfu::vec3_packed pos; mathfu::vec2_packed tc; mathfu::vec3_packed norm; mathfu::vec4_packed tangent;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vertices to computes the information for. </td></tr>
    <tr><td class="paramname">indices</td><td>The indices that make up the mesh. </td></tr>
    <tr><td class="paramname">numverts</td><td>The number of vertices in the vertex array. </td></tr>
    <tr><td class="paramname">numindices</td><td>The number of indices in the index array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b50fd1237871bc8d793827818212860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const mathfu::AffineTransform* fplbase::Mesh::default_bone_transform_inverses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The array of default bone transform inverses. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the array of default bone transform inverses. </dd></dl>

</div>
</div>
<a class="anchor" id="a534ad4d50aec1afdbf649d7831d5ddd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::GatherShaderTransforms </td>
          <td>(</td>
          <td class="paramtype">const mathfu::AffineTransform *&#160;</td>
          <td class="paramname"><em>bone_transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mathfu::AffineTransform *&#160;</td>
          <td class="paramname"><em>shader_transforms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert bone transforms for consumption by a skinning shader. </p>
<p>Vertices are stored in object space, but we need to manipulate them in bone space, so the shader transform multiplies the inverse of the default bone transform. See default_bone_transform_inverses_ for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bone_transforms</td><td>Array of bone transforms, in object space. Length <a class="el" href="classfplbase_1_1_mesh.html#af9e5bcb4f1b14a51fab19dfa924b868a" title="The number of bones in the mesh. ">num_bones()</a>. ith element represents the tranformation of the ith skeleton bone to its animated position. </td></tr>
    <tr><td class="paramname">shader_transforms</td><td>Output array of transforms, one for each bone that has vertices weighted to it. Bones without any weighted vertices are pruned. Length <a class="el" href="classfplbase_1_1_mesh.html#aa440c5b19f40c3719c73e7c1e86b7bdd" title="The number of bones used by the shader. ">num_shader_bones()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7d9c1b83bbd142547c749775c2f6287"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfplbase_1_1_material.html">Material</a>* fplbase::Mesh::GetMaterial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the material associated with the IBO at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the IBO. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the material of the corresponding IBO. </dd></dl>

</div>
</div>
<a class="anchor" id="a1897261b1050950e6d650c19cd28332d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const mathfu::vec3&amp; fplbase::Mesh::max_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum position of an AABB about the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the maximum position of the mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="add6031658ca8b8eb900bd5c63a215d29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const mathfu::vec3&amp; fplbase::Mesh::min_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum position of an AABB about the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the minimum position of the mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="af9e5bcb4f1b14a51fab19dfa924b868a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t fplbase::Mesh::num_bones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bones in the mesh. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bones. </dd></dl>

</div>
</div>
<a class="anchor" id="aa440c5b19f40c3719c73e7c1e86b7bdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t fplbase::Mesh::num_shader_bones </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bones used by the shader. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of bones used by the shader. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b796e760de088d73563b0afed7c6d82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t fplbase::Mesh::num_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of vertices in the VBO. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of vertices in the VBO. </dd></dl>

</div>
</div>
<a class="anchor" id="a552626bc96b1686f4f5ed44718995f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::Render </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_material</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render the mesh. </p>
<p>Call to have the mesh render itself. Uniforms must have been set before calling this. For instanced rendering, pass in a value &gt;1 (needs OpenGL ES 3.0 to work).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>The renderer object to be used. </td></tr>
    <tr><td class="paramname">ignore_material</td><td>Whether to ignore the meshes defined material. </td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to be rendered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af892718f24e323cd1fdf6f52e945d0d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::RenderAAQuadAlongX </td>
          <td>(</td>
          <td class="paramtype">const mathfu::vec3 &amp;&#160;</td>
          <td class="paramname"><em>bottom_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec3 &amp;&#160;</td>
          <td class="paramname"><em>top_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec2 &amp;&#160;</td>
          <td class="paramname"><em>tex_bottom_left</em> = <code>mathfu::vec2(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec2 &amp;&#160;</td>
          <td class="paramname"><em>tex_top_right</em> = <code>mathfu::vec2(1,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for rendering a Quad. </p>
<p>bottom_left and top_right must have their X coordinate be different, but either Y or Z can be the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom_left</td><td>The bottom left coordinate of the Quad. </td></tr>
    <tr><td class="paramname">top_right</td><td>The bottom left coordinate of the Quad. </td></tr>
    <tr><td class="paramname">tex_bottom_left</td><td>The texture coordinates at the bottom left. </td></tr>
    <tr><td class="paramname">tex_top_right</td><td>The texture coordinates at the top right. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a941da21a44789d08f972122633c356af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::RenderAAQuadAlongXNinePatch </td>
          <td>(</td>
          <td class="paramtype">const mathfu::vec3 &amp;&#160;</td>
          <td class="paramname"><em>bottom_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec3 &amp;&#160;</td>
          <td class="paramname"><em>top_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec2i &amp;&#160;</td>
          <td class="paramname"><em>texture_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec4 &amp;&#160;</td>
          <td class="paramname"><em>patch_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for rendering a Quad with nine patch settings. </p>
<p>In the patch_info, the user can define nine patch settings as vec4(x0, y0, x1, y1) where (x0,y0): top-left corner of stretchable area in UV coordinate. (x1,y1): bottom-right corner of stretchable area in UV coordinate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom_left</td><td>The bottom left coordinate of the Quad. </td></tr>
    <tr><td class="paramname">top_right</td><td>The top right coordinate of the Quad. </td></tr>
    <tr><td class="paramname">texture_size</td><td>The size of the texture used by the patches. </td></tr>
    <tr><td class="paramname">patch_info</td><td>Defines how the patches are set up. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f7bfae0ab41c198e1d9843010e049bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::RenderArray </td>
          <td>(</td>
          <td class="paramtype">Primitive&#160;</td>
          <td class="paramname"><em>primitive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders the given vertex and index data directly. </p>
<p>Renders primitives using vertex and index data directly in local memory. This is a convenient alternative to creating a <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> instance for small amounts of data, or dynamic data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitive</td><td>The type of primitive to render the data as. </td></tr>
    <tr><td class="paramname">index_count</td><td>The total number of indices. </td></tr>
    <tr><td class="paramname">format</td><td>The vertex buffer format, following the same rules as described in <a class="el" href="classfplbase_1_1_mesh.html#a99db7c679fa5afbdc4e17cdeb30eaa7e" title="Define the vertex buffer format. ">set_format()</a>. </td></tr>
    <tr><td class="paramname">vertex_size</td><td>The size of an individual vertex. </td></tr>
    <tr><td class="paramname">vertices</td><td>The array of vertices. </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices into the vertex array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6dbef0bc37c522b63c577a4a616f7dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fplbase::Mesh::RenderArray </td>
          <td>(</td>
          <td class="paramtype">Primitive&#160;</td>
          <td class="paramname"><em>primitive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Renders the given vertex data directly. </p>
<p>Renders primitives using vertex data directly in local memory. This is a convenient alternative to creating a <a class="el" href="classfplbase_1_1_mesh.html" title="Abstraction for a set of indices, used for rendering. ">Mesh</a> instance for small amounts of data, or dynamic data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">primitive</td><td>The type of primitive to render the data as. </td></tr>
    <tr><td class="paramname">vertex_count</td><td>The total number of vertices. </td></tr>
    <tr><td class="paramname">format</td><td>The vertex buffer format, following the same rules as described in <a class="el" href="classfplbase_1_1_mesh.html#a99db7c679fa5afbdc4e17cdeb30eaa7e" title="Define the vertex buffer format. ">set_format()</a>. </td></tr>
    <tr><td class="paramname">vertex_size</td><td>The size of an individual vertex. </td></tr>
    <tr><td class="paramname">vertices</td><td>The array of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a679461e3577a5f1a33b924323c011e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::RenderStereo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfplbase_1_1_renderer.html">Renderer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfplbase_1_1_shader.html">Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacefplbase.html#ab4c9bd1f04da97001d01f0dc1f9689ce">Viewport</a> *&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::mat4 *&#160;</td>
          <td class="paramname"><em>mvp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mathfu::vec3 *&#160;</td>
          <td class="paramname"><em>camera_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_material</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>instances</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Render the mesh, itself, into stereoscopic viewports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>The renderer object to be used. </td></tr>
    <tr><td class="paramname">shader</td><td>The shader object to be used. </td></tr>
    <tr><td class="paramname">viewport</td><td>An array with two elements (left and right parameters) for the viewport. </td></tr>
    <tr><td class="paramname">mvp</td><td>An array with two elements (left and right parameters) for the Model View Projection (MVP) matrix. </td></tr>
    <tr><td class="paramname">camera_position</td><td>An array with two elements (left and right parameters) for camera position. </td></tr>
    <tr><td class="paramname">ignore_material</td><td>Whether to ignore the meshes defined material. </td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to be rendered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99db7c679fa5afbdc4e17cdeb30eaa7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::set_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the vertex buffer format. </p>
<p><code>format</code> must have length &lt;= kMaxAttributes, including <code>kEND</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Array of attributes to set the format to, delimitted with <code>kEND</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1f787785d01d9dd731624d3bcef6362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fplbase::Mesh::SetBones </td>
          <td>(</td>
          <td class="paramtype">const mathfu::AffineTransform *&#160;</td>
          <td class="paramname"><em>bone_transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>bone_parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>bone_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bones</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>shader_bone_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_shader_bones</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the bones used by an animated mesh. </p>
<p>If mesh is animated set the transform from a bone's parent space into the bone's local space. Optionally record the bone names, too, for debugging. The shader only accesses a bone if at least one vertex is weighted to it. So, we don't have to pass every bone transform up to the shader. Instead, we compact the bone transforms by passing only those in shader_bone_indices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bone_transforms</td><td>Array of bones to be used. </td></tr>
    <tr><td class="paramname">bone_parents</td><td>Array that contains, for each bone, the index of its parent. </td></tr>
    <tr><td class="paramname">bone_names</td><td>Array containing the names of the bones. </td></tr>
    <tr><td class="paramname">num_bones</td><td>The number of bones in the given array. </td></tr>
    <tr><td class="paramname">shader_bone_indices</td><td>The indices of bones used by the shader. </td></tr>
    <tr><td class="paramname">num_shader_bones</td><td>The number of bones in the shader bones array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5aeaa120faafcf24302e1399f50eb4ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* fplbase::Mesh::shader_bone_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The indices of bones used by the shader. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns an array of indices of bones used by the shader. </dd></dl>

</div>
</div>
<a class="anchor" id="af3db409ea671ecd2fdae87fc47cdb5fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t fplbase::Mesh::VertexSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a> *&#160;</td>
          <td class="paramname"><em>attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fplbase__mesh.html#ga32e078df53a6a42cb90430d93d4df3f5">Attribute</a>&#160;</td>
          <td class="paramname"><em>end</em> = <code><a class="el" href="group__fplbase__mesh.html#gga32e078df53a6a42cb90430d93d4df3f5ad6fe577dc2b397bb3a6922341656a5e9">kEND</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the byte size for a vertex from given attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>The array of attributes describing the vertex. </td></tr>
    <tr><td class="paramname">end</td><td>The attribute to treat as the end of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the byte size based on the given attributes. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="mesh_8h_source.html">mesh.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-49880327-7', 'google.github.io');
ga('send', 'pageview');
</script>
</body>
</html>
